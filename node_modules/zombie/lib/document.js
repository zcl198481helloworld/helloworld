"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _core = require("babel-runtime/core-js")["default"];

// Exports a function for creating/loading new documents.

var assert = require("assert");

var _require = require("jsdom/lib/jsdom/browser");

var browserAugmentation = _require.browserAugmentation;

var browserFeatures = require("jsdom/lib/jsdom/browser/documentfeatures");
var Window = require("jsdom/lib/jsdom/browser/Window");
var DOM = require("./dom");
var EventSource = require("eventsource");
var WebSocket = require("ws");
var XMLHttpRequest = require("./xhr");
var URL = require("url");

// Load/create a new document.
//
// Named arguments:
// browser   - The browser (required)
// history   - Window history (required)
// url       - URL of document to open (defaults to "about:blank")
// method    - HTTP method (defaults to "GET")
// encoding  - Request content type (forms use this)
// params    - Additional request parameters
// html      - Create document with this content instead of loading from URL
// name      - Window name
// referrer  - HTTP referer header
// parent    - Parent document (for frames)
// opener    - Opening window (for window.open)
// target    - Target window name (for form.submit)
//
// Returns a new document with a new window.  The document contents is loaded
// asynchronously, and will trigger a loaded/error event.
module.exports = function loadDocument(args) {
  var browser = args.browser;
  var history = args.history;

  assert(browser && browser.visit, "Missing parameter browser");
  assert(history && history.reload, "Missing parameter history");

  var url = args.url;

  if (url && browser.site) {
    var site = /^(https?:|file:)/i.test(browser.site) ? browser.site : "http://" + browser.site;
    url = URL.resolve(site, URL.parse(URL.format(url)));
  }
  url = url || "about:blank";

  var document = createDocument(_core.Object.assign({ url: url }, args));
  var window = document.parentWindow;

  if (args.html) {
    window._eventQueue.enqueue(function () {
      document.write(args.html); // jshint ignore:line
      document.close();
      browser.emit("loaded", document);
    });
    return document;
  }

  // Let's handle the specifics of each protocol

  var _URL$parse = URL.parse(url);

  var protocol = _URL$parse.protocol;
  var pathname = _URL$parse.pathname;

  switch (protocol) {
    case "about:":
      {
        window._eventQueue.enqueue(function () {
          document.close();
          browser.emit("loaded", document);
        });
        break;
      }

    case "javascript:":
      {
        window._eventQueue.enqueue(function () {
          document.close();
          try {
            window._evaluate(pathname, "javascript:");
            browser.emit("loaded", document);
          } catch (error) {
            browser.emit("error", error);
          }
        });
        break;
      }

    default:
      {
        var method = (args.method || "GET").toUpperCase();
        // Proceeed to load resource ...
        var headers = args.headers || {};
        // HTTP header Referer, but Document property referrer
        headers.referer = headers.referer || args.referrer || browser.referrer || browser.referer || history.url || "";
        // Tell the browser we're looking for an HTML document
        headers.accept = headers.accept || "text/html,*/*";
        // Forms require content type
        if (method === "POST") headers["content-type"] = args.encoding || "application/x-www-form-urlencoded";

        window._eventQueue.http(method, url, { headers: headers, params: args.params, target: document }, function (error, response) {
          if (response) {
            history.updateLocation(window, response.url);
            window._response = response;
          }

          if (response && response.statusCode >= 400) error = new Error("Server returned status code " + response.statusCode + " from " + url);
          if (error) {

            // 4xx/5xx we get an error with an HTTP response
            // Error in body of page helps with debugging
            var message = response && response.body || error.message || error;
            document.write("<html><body>" + message + "</body></html>"); //jshint ignore:line
            document.close();
            browser.emit("error", error);
          } else {
            (function () {

              document.write(response.body); //jshint ignore:line
              document.close();

              // Handle meta refresh.  Automatically reloads new location and counts
              // as a redirect.
              //
              // If you need to check the page before refresh takes place, use this:
              //   browser.wait({
              //     function: function() {
              //       return browser.query('meta[http-equiv="refresh"]');
              //     }
              //   });
              var refreshURL = getMetaRefreshURL(document);
              if (refreshURL) {
                // Allow completion function to run
                window._eventQueue.enqueue(function () {
                  // Count a meta-refresh in the redirects count.
                  history.replace(refreshURL || document.location.href);
                  // This results in a new window getting loaded
                  var newWindow = history.current.window;
                  newWindow.addEventListener("load", function () {
                    newWindow._response.redirects++;
                  });
                });
              } else {

                if (document.documentElement) browser.emit("loaded", document);else browser.emit("error", new Error("Could not parse document at " + response.url));
              }
            })();
          }
        });
        break;
      }
  }

  return document;
};

function getMetaRefreshURL(document) {
  var refresh = document.querySelector("meta[http-equiv=\"refresh\"]");
  if (refresh) {
    var content = refresh.getAttribute("content");
    var match = content.match(/^\s*(\d+)(?:\s*;\s*url\s*=\s*(.*?))?\s*(?:;|$)/i);
    if (match) {
      var refreshTimeout = parseInt(match[1], 10);
      var refreshURL = match[2] || document.location.href;
      if (refreshTimeout >= 0) {
        return refreshURL;
      }
    }
  }
  return null;
}

// Creates an returns a new document attached to the window.
function createDocument(args) {
  var browser = args.browser;

  var features = {
    FetchExternalResources: [],
    ProcessExternalResources: [],
    MutationEvents: "2.0"
  };
  if (browser.hasFeature("scripts", true)) {
    features.FetchExternalResources.push("script");
    features.ProcessExternalResources.push("script");
  }
  if (browser.hasFeature("css", false)) {
    features.FetchExternalResources.push("css");
    features.FetchExternalResources.push("link");
  }
  if (browser.hasFeature("img", false)) features.FetchExternalResources.push("img");
  if (browser.hasFeature("iframe", true)) features.FetchExternalResources.push("iframe");

  // Based on JSDOM.jsdom but skips the document.write
  // Calling document.write twice leads to strange results
  var dom = browserAugmentation(DOM, { parsingMode: "html" });
  var document = new dom.HTMLDocument({ url: args.url, referrer: args.referrer, parsingMode: "html" });
  browserFeatures.applyDocumentFeatures(document, features);
  var window = document.parentWindow;
  setupDocument(document);
  setupWindow(window, args);

  // Give event handler chance to register listeners.
  browser.emit("loading", document);
  return document;
}

function setupDocument(document) {
  var window = document.parentWindow;
  Object.defineProperty(document, "window", {
    value: window,
    enumerable: true
  });
}

// File access, not implemented yet

var File = function File() {
  _classCallCheck(this, File);
};

// Screen object provides access to screen dimensions

var Screen = (function () {
  function Screen() {
    _classCallCheck(this, Screen);

    this.top = this.left = 0;
    this.width = 1280;
    this.height = 800;
  }

  _createClass(Screen, {
    availLeft: {
      get: function () {
        return 0;
      }
    },
    availTop: {
      get: function () {
        return 0;
      }
    },
    availWidth: {
      get: function () {
        return 1280;
      }
    },
    availHeight: {
      get: function () {
        return 800;
      }
    },
    colorDepth: {
      get: function () {
        return 24;
      }
    },
    pixelDepth: {
      get: function () {
        return 24;
      }
    }
  });

  return Screen;
})();

// DOM implementation of URL class

var DOMURL = (function () {
  function DOMURL(url, base) {
    _classCallCheck(this, DOMURL);

    assert(url != null, new DOM.DOMException("Failed to construct 'URL': Invalid URL"));
    if (base) url = URL.resolve(base, url);
    var parsed = URL.parse(url || "about:blank");
    var origin = parsed.protocol && parsed.hostname && "" + parsed.protocol + "//" + parsed.hostname;
    Object.defineProperties(this, {
      hash: { value: parsed.hash, enumerable: true },
      host: { value: parsed.host, enumerable: true },
      hostname: { value: parsed.hostname, enumerable: true },
      href: { value: URL.format(parsed), enumerable: true },
      origin: { value: origin, enumerable: true },
      password: { value: parsed.password, enumerable: true },
      pathname: { value: parsed.pathname, enumerable: true },
      port: { value: parsed.port, enumerable: true },
      protocol: { value: parsed.protocol, enumerable: true },
      search: { value: parsed.search, enumerable: true },
      username: { value: parsed.username, enumerable: true }
    });
  }

  DOMURL.prototype.toString = function toString() {
    return this.href;
  };

  return DOMURL;
})();

function setupWindow(window, args) {
  var document = window.document;

  var global = window.getGlobal();
  var browser = args.browser;
  var history = args.history;
  var parent = args.parent;
  var opener = args.opener;

  var closed = false;

  // Access to browser
  Object.defineProperty(window, "browser", {
    value: browser,
    enumerable: true
  });

  window.name = args.name || "";

  // If this is an iframe within a parent window
  if (parent) {
    window.parent = parent;
    window.top = parent.top;
  } else {
    window.parent = global;
    window.top = global;
  }

  // If this was opened from another window
  window.opener = opener;

  window.console = browser.console;

  // javaEnabled, present in browsers, not in spec Used by Google Analytics see
  /// https://developer.mozilla.org/en/DOM/window.navigator.javaEnabled
  var emptySet = [];
  emptySet.item = function () {
    return undefined;
  };
  emptySet.namedItem = function () {
    return undefined;
  };
  window.navigator = {
    appName: "Zombie",
    cookieEnabled: true,
    javaEnabled: function () {
      return false;
    },
    language: browser.language,
    mimeTypes: emptySet,
    noUI: true,
    platform: process.platform,
    plugins: emptySet,
    userAgent: browser.userAgent,
    vendor: "Zombie Industries"
  };

  // Add cookies, storage, alerts/confirm, XHR, WebSockets, JSON, Screen, etc
  Object.defineProperty(window, "cookies", {
    get: function get() {
      return browser.cookies.serialize(this.location.hostname, this.location.pathname);
    }
  });
  browser._storages.extend(window);

  window.File = File;
  window.Event = DOM.Event;
  window.MouseEvent = DOM.MouseEvent;
  window.MutationEvent = DOM.MutationEvent;
  window.UIEvent = DOM.UIEvent;
  window.screen = new Screen();

  // Base-64 encoding/decoding
  window.atob = function (string) {
    return new Buffer(string, "base64").toString("utf8");
  };
  window.btoa = function (string) {
    return new Buffer(string, "utf8").toString("base64");
  };

  // Constructor for XHLHttpRequest
  window.XMLHttpRequest = function () {
    return new XMLHttpRequest(window);
  };
  window.URL = DOMURL;

  // Web sockets
  window.WebSocket = function (url, protocol) {
    url = DOM.resourceLoader.resolve(document, url);
    var origin = "" + window.location.protocol + "//" + window.location.host;
    return new WebSocket(url, { origin: origin, protocol: protocol });
  };

  window.Image = function (width, height) {
    var img = new DOM.HTMLImageElement(window.document);
    img.width = width;
    img.height = height;
    return img;
  };

  // DataView: get from globals
  window.DataView = DataView;

  window.resizeTo = function (width, height) {
    window.outerWidth = window.innerWidth = width;
    window.outerHeight = window.innerHeight = height;
  };
  window.resizeBy = function (width, height) {
    window.resizeTo(window.outerWidth + width, window.outerHeight + height);
  };

  // Some libraries (e.g. Backbone) check that this property exists before
  // deciding to use onhashchange, so we need to set it to null.
  window.onhashchange = null;

  // -- JavaScript evaluation

  // Evaulate in context of window. This can be called with a script (String) or a function.
  window._evaluate = function (code, filename) {
    var originalInScope = browser._windowInScope;
    try {
      // The current window, postMessage and window.close need this
      browser._windowInScope = window;
      var result = undefined;
      if (typeof code === "string" || code instanceof String) {
        result = global.run(code, filename);
      } else if (code) {
        result = code.call(global);
      }
      browser.emit("evaluated", code, result, filename);
      return result;
    } catch (error) {
      error.filename = error.filename || filename;
      throw error;
    } finally {
      browser._windowInScope = originalInScope;
    }
  };

  // -- Event loop --

  var eventQueue = browser.eventLoop.createEventQueue(window);
  Object.defineProperty(window, "_eventQueue", {
    value: eventQueue
  });
  window.setTimeout = eventQueue.setTimeout.bind(eventQueue);
  window.clearTimeout = eventQueue.clearTimeout.bind(eventQueue);
  window.setInterval = eventQueue.setInterval.bind(eventQueue);
  window.clearInterval = eventQueue.clearInterval.bind(eventQueue);
  window.setImmediate = function (fn) {
    return eventQueue.setTimeout(fn, 0);
  };
  window.clearImmediate = eventQueue.clearTimeout.bind(eventQueue);
  window.requestAnimationFrame = window.setImmediate;

  // Constructor for EventSource, URL is relative to document's.
  window.EventSource = function (url) {
    url = DOM.resourceLoader.resolve(document, url);
    var eventSource = new EventSource(url);
    eventQueue.addEventSource(eventSource);
    return eventSource;
  };

  // -- Interaction --

  window.alert = function (message) {
    var handled = browser.emit("alert", message);
    if (!handled) browser.log("Unhandled window.alert(\"%s\")");
    browser.log("alert(\"%s\")", message);
  };

  window.confirm = function (question) {
    var event = { question: question, response: true };
    var handled = browser.emit("confirm", event);
    if (!handled) browser.log("Unhandled window.confirm(\"%s\")");
    var response = !!event.response;
    browser.log("confirm(\"%s\") -> %ss", question, response);
    return response;
  };

  window.prompt = function (question, value) {
    var event = { question: question, response: value || "" };
    var handled = browser.emit("prompt", event);
    if (!handled) browser.log("Unhandled window.prompt(\"%s\")");
    var response = (event.response || "").toString();
    browser.log("prompt(\"..\") -> \"%s\"", question, response);
    return response;
  };

  // -- Opening and closing --

  // Open one window from another.
  window.open = function (url, name, features) {
    // jshint unused:false
    url = url && DOM.resourceLoader.resolve(document, url);
    return browser.tabs.open({ name: name, url: url, opener: window });
  };

  // Indicates if window was closed
  Object.defineProperty(window, "closed", {
    get: function get() {
      return closed;
    },
    enumerable: true
  });

  // Destroy all the history (and all its windows), frames, and Contextify
  // global.
  window._destroy = function () {
    // We call history.destroy which calls destroy on all windows, so need to
    // avoid infinite loop.
    if (closed) return;

    closed = true;
    // Close all frames first
    for (var i = 0; i < window.length; ++i) {
      window[i].close();
    } // kill event queue, document and window.
    eventQueue.destroy();
    document.close();
    window.dispose();
  };

  // window.close actually closes the tab, and disposes of all windows in the history.
  // Also used to close iframe.
  window.close = function () {
    if (parent || closed) return;
    // Only opener window can close window; any code that's not running from
    // within a window's context can also close window.
    if (browser._windowInScope === opener || browser._windowInScope === null) {
      // Only parent window gets the close event
      browser.emit("closed", window);
      window._destroy();
      history.destroy(); // do this last to prevent infinite loop
    } else browser.log("Scripts may not close windows that were not opened by script");
  };

  // -- Navigating --

  // Each window maintains its own view of history
  var windowHistory = {
    forward: function forward() {
      windowHistory.go(1);
    },
    back: function back() {
      windowHistory.go(-1);
    },
    go: function go(amount) {
      history.go(amount);
    },
    pushState: function pushState() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      history.pushState.apply(history, args);
    },
    replaceState: function replaceState() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      history.replaceState.apply(history, args);
    },
    dump: function dump(output) {
      history.dump(output);
    }
  };
  Object.defineProperties(windowHistory, {
    length: {
      get: function get() {
        return history.length;
      },
      enumerable: true
    },
    state: {
      get: function get() {
        return history.state;
      },
      enumerable: true
    }
  });

  // DOM History object
  window.history = windowHistory;
  /// Actual history, see location getter/setter
  window._history = history;

  // Form submission uses this
  window._submit = function (args) {
    var url = DOM.resourceLoader.resolve(document, args.url);
    var target = args.target || "_self";
    browser.emit("submit", url, target);
    // Figure out which history is going to handle this
    var targetWindow = target === "_self" ? window : target === "_parent" ? window.parent : target === "_top" ? window.top : browser.tabs.open({ name: target });
    var modified = _core.Object.assign({}, args, { url: url, target: target });
    targetWindow._history.submit(modified);
  };

  // JSDOM fires DCL event on document but not on window
  function windowLoaded(event) {
    document.removeEventListener("DOMContentLoaded", windowLoaded);
    window.dispatchEvent(event);
  }
  document.addEventListener("DOMContentLoaded", windowLoaded);

  // Window is now open, next load the document.
  browser.emit("opened", window);
}

// Change location, bypass JSDOM history
Window.prototype.__defineSetter__("location", function (url) {
  return this._history.assign(url);
});

// Change location
DOM.Document.prototype.__defineSetter__("location", function (url) {
  this.parentWindow.location = url;
});

// Help iframes talking with each other
Window.prototype.postMessage = function (data, targetOrigin) {
  // jshint unused:false
  // Create the event now, but dispatch asynchronously
  var event = this.document.createEvent("MessageEvent");
  event.initEvent("message", false, false);
  event.data = data;
  // Window A (source) calls B.postMessage, to determine A we need the
  // caller's window.

  // DDOPSON-2012-11-09 - _windowInScope.getGlobal() is used here so that for
  // website code executing inside the sandbox context, event.source ==
  // window. Even though the _windowInScope object is mapped to the sandboxed
  // version of the object returned by getGlobal, they are not the same object
  // ie, _windowInScope.foo == _windowInScope.getGlobal().foo, but
  // _windowInScope != _windowInScope.getGlobal()
  event.source = (this.browser._windowInScope || this).getGlobal();
  var origin = event.source.location;
  event.origin = URL.format({ protocol: origin.protocol, host: origin.host });
  this.dispatchEvent(event);
};
//# sourceMappingURL=document.js.map