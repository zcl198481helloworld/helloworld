"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _slicedToArray = require("babel-runtime/helpers/sliced-to-array")["default"];

var _core = require("babel-runtime/core-js")["default"];

// See [Web Storage](http://dev.w3.org/html5/webstorage/)
var DOM = require("./dom");

// Implementation of the StorageEvent.

var StorageEvent = (function (_DOM$Event) {
  function StorageEvent(storage, url, key, oldValue, newValue) {
    _classCallCheck(this, StorageEvent);

    _DOM$Event.call(this, "storage");
    this._storage = storage;
    this._url = url;
    this._key = key;
    this._oldValue = oldValue;
    this._newValue = newValue;
  }

  _inherits(StorageEvent, _DOM$Event);

  _createClass(StorageEvent, {
    url: {
      get: function () {
        return this._url;
      }
    },
    storageArea: {
      get: function () {
        return this._storage;
      }
    },
    key: {
      get: function () {
        return this._key;
      }
    },
    oldValue: {
      get: function () {
        return this._oldValue;
      }
    },
    newValue: {
      get: function () {
        return this._newValue;
      }
    }
  });

  return StorageEvent;
})(DOM.Event);

// Storage area. The storage area is shared by multiple documents of the same
// origin. For session storage, they must also share the same browsing context.

var StorageArea = (function () {
  function StorageArea() {
    _classCallCheck(this, StorageArea);

    this._items = {};
    this._storages = [];
  }

  // Fire a storage event. Fire in all documents that share this storage area,
  // except for the source document.

  StorageArea.prototype._fire = function _fire(source, key, oldValue, newValue) {
    for (var _iterator = this._storages, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _ref2 = _slicedToArray(_ref, 2);

      var storage = _ref2[0];
      var _window = _ref2[1];

      if (storage === source) continue;
      var _event = new StorageEvent(storage, _window.location.href, key, oldValue, newValue);
      _window.dispatchEvent(_event);
    }
  };

  // Get key by ordinal position.

  StorageArea.prototype.key = function key(index) {
    return _core.Object.keys(this._items)[index];
  };

  // Get value from key

  StorageArea.prototype.get = function get(key) {
    return this._items[key] || null;
  };

  // Set the value of a key. We also need the source storage (so we don't send
  // it a storage event).

  StorageArea.prototype.set = function set(source, key, value) {
    var oldValue = this._items[key];
    this._items[key] = value;
    this._fire(source, key, oldValue, value);
  };

  // Remove the value at the key. We also need source storage (see set above).

  StorageArea.prototype.remove = function remove(source, key) {
    var oldValue = this._items[key];
    delete this._items[key];
    this._fire(source, key, oldValue);
  };

  // Remove all values. We also need source storage (see set above).

  StorageArea.prototype.clear = function clear(source) {
    this._items = {};
    this._fire(source);
  };

  StorageArea.prototype.toString = function toString() {
    var _this = this;

    return _core.Object.keys(this._items).map(function (key) {
      return "" + key + " = " + _this._items[key];
    }).join("\n");
  };

  // Associate local/sessionStorage and window with this storage area. Used when firing events.

  StorageArea.prototype.associate = function associate(storage, window) {
    this._storages.push([storage, window]);
  };

  _createClass(StorageArea, {
    length: {

      // Return number of key/value pairs.

      get: function () {
        return _core.Object.keys(this._items).length;
      }
    },
    pairs: {
      get: function () {
        var _this = this;

        return _core.Object.keys(this._items).map(function (key) {
          return [key, _this._items[key]];
        });
      }
    }
  });

  return StorageArea;
})();

// Implementation of the Storage interface, used by local and session storage.

var Storage = (function () {
  function Storage(area) {
    _classCallCheck(this, Storage);

    this._area = area;
  }

  // ### storage.key(index) => String
  //
  // Returns the key at this position.

  Storage.prototype.key = function key(index) {
    return this._area.key(index);
  };

  // ### storage.getItem(key) => Object
  //
  // Returns item by key.

  Storage.prototype.getItem = function getItem(key) {
    return this._area.get(key.toString());
  };

  // ### storage.setItem(key, Object)
  //
  // Add item or change value of existing item.

  Storage.prototype.setItem = function setItem(key, value) {
    this._area.set(this, key.toString(), value);
  };

  // ### storage.removeItem(key)
  //
  // Remove item.

  Storage.prototype.removeItem = function removeItem(key) {
    this._area.remove(this, key.toString());
  };

  // ### storage.clear()
  //
  // Remove all items.

  Storage.prototype.clear = function clear() {
    this._area.clear(this);
  };

  // Dump to a string, useful for debugging.

  Storage.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    return this._area.dump(output);
  };

  _createClass(Storage, {
    length: {

      // ### storage.length => Number
      //
      // Returns the number of key/value pairs in this storage.

      get: function () {
        return this._area.length;
      }
    }
  });

  return Storage;
})();

// Combined local/session storage.

var Storages = (function () {
  function Storages() {
    _classCallCheck(this, Storages);

    this._locals = {};
    this._sessions = {};
  }

  // Return local Storage based on the document origin (hostname/port).

  Storages.prototype.local = function local(host) {
    if (!this._locals[host]) this._locals[host] = new StorageArea();
    return new Storage(this._locals[host]);
  };

  // Return session Storage based on the document origin (hostname/port).

  Storages.prototype.session = function session(host) {
    if (!this._sessions[host]) this._sessions[host] = new StorageArea();
    return new Storage(this._sessions[host]);
  };

  // Extend window with local/session storage support.

  Storages.prototype.extend = function extend(window) {
    var storages = this;
    window.StorageEvent = StorageEvent;
    Object.defineProperties(window, {
      localStorage: {
        get: function get() {
          var _ref = this;

          var document = _ref.document;

          if (!document._localStorage) document._localStorage = storages.local(document.location.host);
          return document._localStorage;
        }
      },
      sessionStorage: {
        get: function get() {
          var _ref = this;

          var document = _ref.document;

          if (!document._sessionStorage) document._sessionStorage = storages.session(document.location.host);
          return document._sessionStorage;
        }
      } });
  };

  // Used to dump state to console (debuggin)

  Storages.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    for (var _iterator = this._locals, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var domain = _ref;

      var area = this._locals[domain];
      output.write("" + domain + " local:\n");
      for (var _iterator2 = area.pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _ref22 = _slicedToArray(_ref2, 2);

        var _name = _ref22[0];
        var value = _ref22[1];

        output.write("  " + _name + " = " + value + "\n");
      }
    }
    for (var _iterator3 = this._sessions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.$for.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var domain = _ref3;

      var area = this._sessions[domain];
      output.push("" + domain + " session:\n");
      for (var _iterator4 = area.pairs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _core.$for.getIterator(_iterator4);;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _ref42 = _slicedToArray(_ref4, 2);

        var _name2 = _ref42[0];
        var value = _ref42[1];

        output.write("  " + _name2 + " = " + value + "\n");
      }
    }
  };

  // browser.saveStorage uses this

  Storages.prototype.save = function save() {
    var serialized = ["# Saved on " + new Date().toISOString()];
    for (var _iterator = this._locals, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var domain = _ref;

      var area = this._locals[domain];
      var pairs = area.pairs;
      if (pairs.length) {
        serialized.push("" + domain + " local:");
        for (var _iterator2 = area.pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var _ref22 = _slicedToArray(_ref2, 2);

          var _name = _ref22[0];
          var value = _ref22[1];

          serialized.push("  " + escape(_name) + " = " + escape(value));
        }
      }
    }
    for (var _iterator3 = this._sessions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.$for.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var domain = _ref3;

      var area = this._sessions[domain];
      var pairs = area.pairs;
      if (pairs.length) {
        serialized.push("" + domain + " session:");
        for (var _iterator4 = area.pairs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _core.$for.getIterator(_iterator4);;) {
          var _ref4;

          if (_isArray4) {
            if (_i4 >= _iterator4.length) break;
            _ref4 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done) break;
            _ref4 = _i4.value;
          }

          var _ref42 = _slicedToArray(_ref4, 2);

          var _name2 = _ref42[0];
          var value = _ref42[1];

          serialized.push("  " + escape(_name2) + " = " + escape(value));
        }
      }
    }
    return serialized.join("\n") + "\n";
  };

  // browser.loadStorage uses this

  Storages.prototype.load = function load(serialized) {
    var storage = null;
    for (var _iterator = serialized.split(/\n+/), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var item = _ref;

      if (item[0] === "#" || item === "") continue;
      if (item[0] === " ") {
        var _item$split = item.split("=");

        var _item$split2 = _slicedToArray(_item$split, 2);

        var key = _item$split2[0];
        var value = _item$split2[1];

        if (storage) storage.setItem(unescape(key.trim()), unescape(value.trim()));else throw new Error("Must specify storage type using local: or session:");
      } else {
        var _item$split3 = item.split(" ");

        var _item$split32 = _slicedToArray(_item$split3, 2);

        var domain = _item$split32[0];
        var type = _item$split32[1];

        if (type === "local:") {
          storage = this.local(domain);
        } else if (type === "session:") {
          storage = this.session(domain);
        } else throw new Error("Unkown storage type " + type);
      }
    }
  };

  return Storages;
})();

module.exports = Storages;
//# sourceMappingURL=storage.js.map