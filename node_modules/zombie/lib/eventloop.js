"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _toConsumableArray = require("babel-runtime/helpers/to-consumable-array")["default"];

var _core = require("babel-runtime/core-js")["default"];

// The event loop.
//
// Each browser has an event loop, which processes asynchronous events like
// loading pages and resources, XHR, timeouts and intervals, etc. These are
// procesed in order.
//
// The purpose of the event loop is two fold:
// - To get events processed in the right order for the active window (and only
//   the active window)
// - And to allow the code to wait until all events have been processed
//   (browser.wait, .visit, .pressButton, etc)
//
// The event loop has one interesting method: `wait`.
//
// Each window maintains its own event queue. Its interesting methods are
// `enqueue`, `http`, `dispatch` and the timeout/interval methods.

var assert = require("assert");

var _require = require("events");

var EventEmitter = _require.EventEmitter;

// Wrapper for a timeout (setTimeout)

var Timeout = (function () {

  // eventQueue - Reference to the event queue
  // fn         - When timer fires, evaluate this function
  // delay      - How long to wait
  // remove     - Call this to discard timer
  //
  // Instance variables add:
  // handle  - Node.js timeout handle
  // next    - When is this timer firing next

  function Timeout(eventQueue, fn, delay, remove) {
    _classCallCheck(this, Timeout);

    this.eventQueue = eventQueue;
    this.fn = fn;
    this.delay = Math.max(delay || 0, 0);
    this.remove = remove;

    this.handle = _core.global.setTimeout(this.fire.bind(this), this.delay);
    this.next = Date.now() + this.delay;
  }

  Timeout.prototype.fire = function fire() {
    var _this = this;

    // In response to Node firing setTimeout, but only allowed to process this
    // event during a wait()
    this.eventQueue.enqueue(function () {
      var eventLoop = _this.eventQueue.eventLoop;

      eventLoop.emit("setTimeout", _this.fn, _this.delay);
      try {
        _this.eventQueue.window._evaluate(_this.fn);
      } catch (error) {
        eventLoop.emit("error", error);
      }
    });
    this.remove();
  };

  // clearTimeout

  Timeout.prototype.stop = function stop() {
    _core.global.clearTimeout(this.handle);
    this.remove();
  };

  return Timeout;
})();

// Wapper for an interval (setInterval)

var Interval = (function () {

  // eventQueue - Reference to the event queue
  // fn        - When timer fires, evaluate this function
  // interval  - Interval between firing
  // remove    - Call this to discard timer
  //
  // Instance variables add:
  // handle  - Node.js interval handle
  // next    - When is this timer firing next

  function Interval(eventQueue, fn, interval, remove) {
    _classCallCheck(this, Interval);

    this.eventQueue = eventQueue;
    this.fn = fn;
    this.interval = Math.max(interval || 0, 0);
    this.remove = remove;
    this.fireInProgress = false;
    this.handle = _core.global.setInterval(this.fire.bind(this), this.interval);
    this.next = Date.now() + this.interval;
  }

  Interval.prototype.fire = function fire() {
    var _this = this;

    // In response to Node firing setInterval, but only allowed to process this
    // event during a wait()
    this.next = Date.now() + this.interval;

    // setInterval events not allowed to overlap, don't queue two at once
    if (this.fireInProgress) {
      return;
    }this.fireInProgress = true;
    this.eventQueue.enqueue(function () {
      _this.fireInProgress = false;

      var eventLoop = _this.eventQueue.eventLoop;

      eventLoop.emit("setInterval", _this.fn, _this.interval);
      try {
        _this.eventQueue.window._evaluate(_this.fn);
      } catch (error) {
        eventLoop.emit("error", error);
      }
    });
  };

  // clearTimeout

  Interval.prototype.stop = function stop() {
    _core.global.clearInterval(this.handle);
    this.remove();
  };

  return Interval;
})();

// Each window has an event queue that holds all pending events.  Various
// browser features push new functions into the queue (e.g. process XHR
// response, setTimeout fires).  The event loop is responsible to pop these
// events from the queue and run them, but only during browser.wait().
//
// In addition, the event queue keeps track of all outstanding timers
// (setTimeout/setInterval) so it can return consecutive handles and clean them
// up during window.destroy().
//
// In addition, we keep track of when the browser is expecting an event to
// arrive in the queue (e.g. sent XHR request, expecting an event to process the
// response soon enough).  The event loop uses that to determine if it's worth
// waiting.

var EventQueue = (function () {

  // Instance variables:
  // browser          - Reference to the browser
  // eventLoop        - Reference to the browser's event loop
  // queue            - FIFO queue of functions to call
  // expecting        - These are holding back the event loop
  // timers           - Sparse array of timers (index is the timer handle)
  // eventSources     - Additional sources for events (SSE, WS, etc)
  // nextTimerHandle  - Value of next timer handler

  function EventQueue(window) {
    _classCallCheck(this, EventQueue);

    this.window = window;
    this.browser = window.browser;
    this.eventLoop = this.browser.eventLoop;
    this.queue = [];
    this.expecting = 0;
    this.timers = [];
    this.eventSources = [];
    this.nextTimerHandle = 1;
  }

  // Cleanup when we dispose of the window

  EventQueue.prototype.destroy = function destroy() {
    if (!this.queue) {
      return;
    }this.queue = null;

    for (var _iterator = this.timers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var timer = _ref;

      if (timer) timer.stop();
    }
    this.timers = null;

    for (var _iterator2 = this.eventSources, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var eventSource = _ref2;

      //if (eventSource)
      eventSource.close();
    }
    this.eventSources = null;
  };

  // Add a function to the event queue, to be executed in order.

  EventQueue.prototype.enqueue = function enqueue(fn) {
    assert(this.queue, "This browser has been destroyed");
    assert(typeof fn === "function", "eventLoop.enqueue called without a function");

    if (fn) {
      this.queue.push(fn);
      this.eventLoop.run();
    }
  };

  // Event loop uses this to grab event from top of the queue.

  EventQueue.prototype.dequeue = function dequeue() {
    assert(this.queue, "This browser has been destroyed");

    var fn = this.queue.shift();
    if (fn) {
      return fn;
    }for (var _iterator = [].concat(_toConsumableArray(this.window.frames)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var frame = _ref;

      var childFn = frame._eventQueue.dequeue();
      if (childFn) {
        return childFn;
      }
    }
    return null;
  };

  // Makes an HTTP request.
  //
  // Parameters are:
  // method   - Method (defaults to GET)
  // url      - URL (string)
  // options  - See below
  // callback - Called with error, or null and response
  //
  // Options:
  //   headers   - Name/value pairs of headers to send in request
  //   params    - Parameters to pass in query string or document body
  //   body      - Request document body
  //   timeout   - Request timeout in milliseconds (0 or null for no timeout)
  //
  // Calls callback with response error or null and response object.

  EventQueue.prototype.http = function http(method, url, options, callback) {
    var _this = this;

    assert(this.queue, "This browser has been destroyed");

    // We're expecting to queue an event, event loop should wait
    ++this.expecting;
    this.browser.resources.request(method, url, options, function (error, response) {
      --_this.expecting;
      // We can't cancel pending requests, but we can ignore the response if
      // window already closed
      if (_this.queue) {
        // This will get completion function to execute, e.g. to check a page
        // before meta tag refresh
        _this.enqueue(function () {
          callback(error, response);
        });
      }
    });
  };

  // Fire an error event.  Used by JSDOM patches.

  EventQueue.prototype.onerror = function onerror(error) {
    assert(this.queue, "This browser has been destroyed");

    this.eventLoop.emit("error", error);

    var event = this.window.document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = error.message;
    event.error = error;
    this.window.dispatchEvent(event);
  };

  // -- EventSource --

  EventQueue.prototype.addEventSource = function addEventSource(eventSource) {
    var _this = this;

    assert(this.queue, "This browser has been destroyed");

    this.eventSources.push(eventSource);

    var emit = eventSource.emit;
    eventSource.emit = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.eventLoop.emit("serverEvent");
      _this.enqueue(function () {
        emit.apply(eventSource, args);
      });
    };
  };

  // -- Timers --

  // Window.setTimeout

  EventQueue.prototype.setTimeout = function setTimeout(fn) {
    var _this = this;

    var delay = arguments[1] === undefined ? 0 : arguments[1];

    assert(this.queue, "This browser has been destroyed");
    if (!fn) {
      return;
    }var handle = this.nextTimerHandle;
    ++this.nextTimerHandle;
    this.timers[handle] = new Timeout(this, fn, delay, function () {
      delete _this.timers[handle];
    });
    return handle;
  };

  // Window.clearTimeout

  EventQueue.prototype.clearTimeout = function clearTimeout(handle) {
    assert(this.queue, "This browser has been destroyed");

    var timer = this.timers[handle];
    if (timer) timer.stop();
  };

  // Window.setInterval

  EventQueue.prototype.setInterval = function setInterval(fn) {
    var _this = this;

    var interval = arguments[1] === undefined ? 0 : arguments[1];

    assert(this.queue, "This browser has been destroyed");
    if (!fn) {
      return;
    }var handle = this.nextTimerHandle;
    ++this.nextTimerHandle;
    this.timers[handle] = new Interval(this, fn, interval, function () {
      delete _this.timers[handle];
    });
    return handle;
  };

  // Window.clearInterval

  EventQueue.prototype.clearInterval = function clearInterval(handle) {
    assert(this.queue, "This browser has been destroyed");

    var timer = this.timers[handle];
    if (timer) timer.stop();
  };

  _createClass(EventQueue, {
    expected: {

      // -- Events --

      // Any events expected in the future?

      get: function () {
        return !!(this.expecting || [].concat(_toConsumableArray(this.window.frames)).filter(function (frame) {
          return frame._eventQueue.expected;
        }).length);
      }
    },
    next: {

      // Returns the timestamp of the next timer event

      get: function () {
        var timers = this.timers.map(function (timer) {
          return timer.next;
        });
        var frames = [].concat(_toConsumableArray(this.window.frames)).map(function (frame) {
          return frame._eventQueue.next;
        });
        return timers.concat(frames).sort()[0] || Infinity;
      }
    }
  });

  return EventQueue;
})();

// The browser event loop.
//
// Each browser has one event loop that processes events from the queues of the
// currently active window and its frames (child windows).
//
// The wait method is responsible to process all pending events.  It goes idle
// once:
// - There are no more events waiting in the queue (of the active window)
// - There are no more timers waiting to fire (next -> Infinity)
// - No future events are expected to arrive (e.g. in-progress XHR requests)
//
// The wait method will complete before the loop goes idle, if:
// - Past the specified timeout
// - The next scheduled timer is past the specified timeout
// - The completio function evaluated to true
//
// While processing, the event loop emits the following events (on the browser
// object):
// tick(next) - Emitted after executing a single event; the argument is the
//              expected duration until the next event (in ms)
// idle       - Emitted when there are no more events (queued or expected)
// error(err) - Emitted after an error
module.exports = (function (_EventEmitter) {

  // Instance variables are:
  // active    - Currently active window
  // browser   - Reference to the browser
  // running   - True when inside a run loop
  // waiting   - Counts in-progess calls to wait (waiters?)

  function EventLoop(browser) {
    _classCallCheck(this, EventLoop);

    this.browser = browser;
    this.active = null;
    this.running = false;
    this.waiting = 0;
  }

  _inherits(EventLoop, _EventEmitter);

  // -- The wait function --

  // Wait until one of these happen:
  // 1. We run out of events to process; callback is called with null and false
  // 2. The completion function evaluates to true; callback is called with null
  //    and false
  // 3. The time duration elapsed; callback is called with null and true
  // 2. An error occurs; callback is called with an error
  //
  // Duration is specifies in milliseconds or string form (e.g. "15s").
  //
  // Completion function is called with the currently active window (may change
  // during page navigation or form submission) and how long until the next
  // event, and returns true to stop waiting, any other value to continue
  // processing events.
  //
  //
  // waitDuration       - How long to wait (ms)
  // completionFunction - Returns true for early completion

  EventLoop.prototype.wait = function wait(waitDuration, completionFunction, callback) {
    assert(waitDuration, "Wait duration required, cannot be 0");
    var eventLoop = this;

    ++eventLoop.waiting;
    // Someone (us) just started paying attention, start processing events
    if (eventLoop.waiting === 1) setImmediate(function () {
      return eventLoop.run();
    });

    // The timer fires when we waited long enough, we need timeoutOn to tell if
    // the next event is past the wait duration and there's no point in waiting
    // further
    var timer = _core.global.setTimeout(timeout, waitDuration);
    var timeoutOn = Date.now() + waitDuration;

    // Fired after every event, decide if we want to stop waiting
    function ontick(next) {
      // No point in waiting that long
      if (next >= timeoutOn) {
        timeout();
        return;
      }

      var activeWindow = eventLoop.active;
      if (completionFunction && activeWindow.document.documentElement) {
        try {
          var waitFor = Math.max(next - Date.now(), 0);
          // Event processed, are we ready to complete?
          var completed = completionFunction(activeWindow, waitFor);
          if (completed) done();
        } catch (error) {
          done(error);
        }
      }
    }
    eventLoop.on("tick", ontick);

    // Fired when there are no more events to process
    eventLoop.once("idle", done);

    // Stop on first error reported (document load, script, etc)
    // Event loop errors also propagated to the browser
    eventLoop.browser.once("error", done);

    // We gave up, could be result of slow response ...
    function timeout() {
      if (eventLoop.expected) done(new Error("Timeout: did not get to load all resources on this page"));else done();
    }

    // The wait is over ...
    function done(error) {
      _core.global.clearTimeout(timer);
      eventLoop.removeListener("tick", ontick);
      eventLoop.removeListener("idle", done);
      eventLoop.browser.removeListener("error", done);

      --eventLoop.waiting;
      callback(error);
    }
  };

  EventLoop.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    if (this.running) output.write("Event loop: running\n");else if (this.expected) output.write("Event loop: waiting for " + this.expected + " events\n");else if (this.waiting) output.write("Event loop: waiting\n");else output.write("Event loop: idle\n");
  };

  // -- Event queue management --

  // Creates and returns a new event queue (see EventQueue).

  EventLoop.prototype.createEventQueue = function createEventQueue(window) {
    return new EventQueue(window);
  };

  // Set the active window. Suspends processing events from any other window, and
  // switches to processing events from this window's queue.

  EventLoop.prototype.setActiveWindow = function setActiveWindow(window) {
    if (window === this.active) {
      return;
    }this.active = window;
    this.run(); // new window, new events?
  };

  // -- Event processing --

  // Grabs next event from the queue, processes it and notifies all listeners.
  // Keeps processing until the queue is empty or all listeners are gone. You
  // only need to bootstrap this when you suspect it's not recursing.

  EventLoop.prototype.run = function run() {
    var _this = this;

    // A lot of code calls run() without checking first, so not uncommon to have
    // concurrent executions of this function
    if (this.running) {
      return;
    } // Is there anybody out there?
    if (this.waiting === 0) {
      return;
    } // Give other (Node) events a chance to process
    this.running = true;
    setImmediate(function () {
      _this.running = false;
      try {

        // Are there any open windows?
        if (!_this.active) {
          _this.emit("idle");
          return;
        }
        // Don't run event outside browser.wait()
        if (_this.waiting === 0) return;

        var jsdomQueue = _this.active.document._queue;
        var _event = _this.active._eventQueue.dequeue();
        if (_event) {
          // Process queued function, tick, and on to next event
          _event();
          _this.emit("tick", 0);
          _this.run();
        } else if (_this.expected > 0) {
          // We're waiting for some events to come along, don't know when,
          // but they'll call run for us
          _this.emit("tick", 0);
        } else if (jsdomQueue.tail) {
          jsdomQueue.resume();
          _this.run();
        } else {
          // All that's left are timers, and not even that if next == Infinity
          var next = _this.active._eventQueue.next;
          if (isFinite(next)) _this.emit("tick", next);else _this.emit("idle");
        }
      } catch (error) {
        _this.emit("error", error);
      }
    });
  };

  _createClass(EventLoop, {
    expected: {

      // Are there any expected events for the active window?

      get: function () {
        return this.active && this.active._eventQueue.expected;
      }
    }
  });

  return EventLoop;
})(EventEmitter);
//# sourceMappingURL=eventloop.js.map