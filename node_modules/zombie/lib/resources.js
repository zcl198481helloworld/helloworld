"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _slicedToArray = require("babel-runtime/helpers/sliced-to-array")["default"];

var _toArray = require("babel-runtime/helpers/to-array")["default"];

var _core = require("babel-runtime/core-js")["default"];

// Retrieve resources (HTML pages, scripts, XHR, etc).
//
// If count is unspecified, defaults to at least one.
//
// Each browser has a resources objects that allows you to:
// - Inspect the history of retrieved resources, useful for troubleshooting
//   issues related to resource loading
// - Request resources directly, but have Zombie handle cookies,
//   authentication, etc
// - Implement new mechanism for retrieving resources, for example, add new
//   protocols or support new headers

var assert = require("assert");
var Bluebird = require("bluebird");
var DOM = require("./dom");
var File = require("fs");
var HTTP = require("http");
var iconv = require("iconv-lite");
var Path = require("path");
var QS = require("querystring");
var Request = require("request");
var URL = require("url");
var Zlib = require("zlib");

// Each browser has a resources object that provides the means for retrieving
// resources and a list of all retrieved resources.
//
// The object is an array, and its elements are the resources.

var Resources = (function (_Array) {
  function Resources(browser) {
    _classCallCheck(this, Resources);

    this.browser = browser;
    this.pipeline = Resources.pipeline.slice();
  }

  _inherits(Resources, _Array);

  // Make an HTTP request (also supports file: protocol).
  //
  // method    - Request method (GET, POST, etc)
  // url       - Request URL
  // options   - See below
  // callback  - Called with error, or null and response
  //
  // Without callback, returns a promise.
  //
  // Options:
  //   headers   - Name/value pairs of headers to send in request
  //   params    - Parameters to pass in query string or document body
  //   body      - Request document body
  //   timeout   - Request timeout in milliseconds (0 or null for no timeout)
  //
  // Response contains:
  //   url         - Actual resource URL (changed by redirects)
  //   statusCode  - Status code
  //   statusText  - HTTP status text ("OK", "Not Found" etc)
  //   headers     - Response headers
  //   body        - Response body
  //   redirects   - Number of redirects followed

  Resources.prototype.request = function request(method, url) {
    var _this = this;

    var options = arguments[2] === undefined ? {} : arguments[2];
    var callback = arguments[3] === undefined ? null : arguments[3];

    if (!callback && typeof options === "function") {
      var _ref = [{}, options];

      var _ref2 = _slicedToArray(_ref, 2);

      options = _ref2[0];
      callback = _ref2[1];
    }

    var request = {
      method: method.toUpperCase(),
      url: url,
      headers: options.headers || {},
      params: options.params,
      body: options.body,
      time: Date.now(),
      timeout: options.timeout || 0,
      strictSSL: this.browser.strictSSL,
      localAddress: this.browser.localAddress || 0
    };

    var resource = {
      request: request,
      target: options.target
    };
    this.push(resource);
    this.browser.emit("request", request);

    var promise = new Bluebird(function (resolve, reject) {
      _this.runPipeline(request, function (error, response) {
        if (error) {
          resource.error = error;
          reject(error);
        } else {
          response.url = response.url || request.url;
          response.statusCode = response.statusCode || 200;
          response.statusText = HTTP.STATUS_CODES[response.statusCode] || "Unknown";
          response.headers = response.headers || {};
          response.redirects = response.redirects || 0;
          response.time = Date.now();
          resource.response = response;

          _this.browser.emit("response", request, response);
          resolve(resource.response);
        }
      });
    });

    if (callback) {
      promise.done(function (response) {
        return callback(null, response);
      }, callback);
    } else {
      return promise;
    }
  };

  // GET request.
  //
  // url       - Request URL
  // options   - See request() method
  // callback  - Called with error, or null and response

  Resources.prototype.get = function get(url, options, callback) {
    return this.request("get", url, options, callback);
  };

  // POST request.
  //
  // url       - Request URL
  // options   - See request() method
  // callback  - Called with error, or null and response

  Resources.prototype.post = function post(url, options, callback) {
    return this.request("post", url, options, callback);
  };

  // Human readable resource listing.
  //
  // output - Write to this stream (optional)

  Resources.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    if (this.length === 0) {
      output.write("No resources\n");
      return;
    }

    for (var _iterator = this, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var resource = _ref;
      var request = resource.request;
      var response = resource.response;
      var error = resource.error;
      var target = resource.target;

      // Write summary request/response header
      if (response) output.write("" + request.method + " " + response.url + " - " + response.statusCode + " " + response.statusText + " - " + (response.time - request.time) + "ms\n");else output.write("" + resource.request.method + " " + resource.request.url + "\n");

      // Tell us which element/document is loading this.
      if (target instanceof DOM.Document) {
        output.write("  Loaded as HTML document\n");
      } else if (target) {
        if (target.id) output.write("  Loading by element #" + target.id + "\n");else output.write("  Loading as " + target.tagName + " element\n");
      }

      // If response, write out response headers and sample of document entity
      // If error, write out the error message
      // Otherwise, indicate this is a pending request
      if (response) {
        if (response.redirects) output.write("  Followed " + response.redirects + " redirects\n");
        for (var _name in response.headers) {
          var value = response.headers[_name];
          output.write("  " + _name + ": " + value + "\n");
        }
        output.write("\n");
        var sample = response.body.slice(0, 250).toString("utf8").split("\n").map(function (line) {
          return "  " + line;
        }).join("\n");
        output.write(sample);
      } else if (error) {
        output.write("  Error: " + error.message + "\n");
      } else output.write("  Pending since " + new Date(request.time) + "\n");
      // Keep them separated
      output.write("\n\n");
    }
  };

  // Add a request/response handler.  This handler will only be used by this
  // browser.

  Resources.prototype.addHandler = function addHandler(handler) {
    assert(handler.call, "Handler must be a function");
    assert(handler.length === 2 || handler.length === 3, "Handler function takes 2 (request handler) or 3 (reponse handler) arguments");
    this.pipeline.push(handler);
  };

  // Processes the request using the pipeline.

  Resources.prototype.runPipeline = function runPipeline(request, callback) {
    var _ref = this;

    var browser = _ref.browser;

    var requestHandlers = this.pipeline.filter(function (fn) {
      return fn.length === 2;
    }).concat(Resources.makeHTTPRequest);
    var responseHandlers = this.pipeline.filter(function (fn) {
      return fn.length === 3;
    });

    var response = null;
    // Called to execute the next request handler.
    function nextRequestHandler(error, responseFromHandler) {
      if (error) {
        callback(error);
      } else if (responseFromHandler) {
        // Received response, switch to processing request
        response = responseFromHandler;
        // If we get redirected and the final handler doesn't provide a URL (e.g.
        // mock response), then without this we end up with the original URL.
        response.url = response.url || request.url;
        nextResponseHandler();
      } else {
        // Use the next request handler.
        var handler = requestHandlers.shift();
        try {
          handler.call(browser, request, nextRequestHandler);
        } catch (error) {
          callback(error);
        }
      }
    }

    // Called to execute the next response handler.
    function nextResponseHandler(error, responseFromHandler) {
      if (error) {
        callback(error);
      } else {
        if (responseFromHandler) response = responseFromHandler;
        var handler = responseHandlers.shift();
        if (handler) {
          // Use the next response handler
          try {
            handler.call(browser, request, response, nextResponseHandler);
          } catch (error) {
            callback(error);
          }
        } else {
          // No more handlers, callback with response.
          callback(null, response);
        }
      }
    }

    // Start with first request handler
    nextRequestHandler();
  };

  return Resources;
})(Array);

// -- Handlers

// Add a request/response handler.  This handler will be used in all browsers.
Resources.addHandler = function (handler) {
  assert(handler.call, "Handler must be a function");
  assert(handler.length === 2 || handler.length === 3, "Handler function takes 2 (request handler) or 3 (response handler) arguments");
  this.pipeline.push(handler);
};

// This handler normalizes the request URL.
//
// It turns relative URLs into absolute URLs based on the current document URL
// or base element, or if no document open, based on browser.site property.
//
// Also handles file: URLs and creates query string from request.params for
// GET/HEAD/DELETE requests.
Resources.normalizeURL = function (request, next) {
  if (/^file:/.test(request.url)) {
    // File URLs are special, need to handle missing slashes and not attempt
    // to parse (downcases path)
    request.url = request.url.replace(/^file:\/{1,3}/, "file:///");
  } else {
    // Resolve URL relative to document URL/base, or for new browser, using
    // Browser.site
    if (this.document) request.url = DOM.resourceLoader.resolve(this.document, request.url);else request.url = URL.resolve(this.site || "http://localhost", request.url);
  }

  if (request.params) {
    var method = request.method;

    if (method === "GET" || method === "HEAD" || method === "DELETE") {
      // These methods use query string parameters instead
      var uri = URL.parse(request.url, true);
      _core.Object.assign(uri.query, request.params);
      request.url = URL.format(uri);
    }
  }

  next();
};

// This handler mergers request headers.
//
// It combines headers provided in the request with custom headers defined by
// the browser (user agent, authentication, etc).
//
// It also normalizes all headers by down-casing the header names.
Resources.mergeHeaders = function (request, next) {
  // Header names are down-cased and over-ride default
  var headers = {
    "user-agent": this.userAgent
  };

  // Merge custom headers from browser first, followed by request.
  for (var _name in this.headers) {
    headers[_name.toLowerCase()] = this.headers[_name];
  }
  if (request.headers) {
    for (var _name2 in request.headers) {
      headers[_name2.toLowerCase()] = request.headers[_name2];
    }
  }

  var _URL$parse = URL.parse(request.url);

  var host = _URL$parse.host;

  // Depends on URL, don't allow over-ride.
  headers.host = host;

  // HTTP Basic authentication
  var authenticate = { host: host, username: null, password: null };
  this.emit("authenticate", authenticate);
  var username = authenticate.username;
  var password = authenticate.password;

  if (username && password) {
    this.log("Authenticating as " + username + ":" + password);
    var base64 = new Buffer("" + username + ":" + password).toString("base64");
    headers.authorization = "Basic " + base64;
  }

  request.headers = headers;
  next();
};

// Depending on the content type, this handler will create a request body from
// request.params, set request.multipart for uploads.
Resources.createBody = function (request, next) {
  var method = request.method;

  if (method !== "POST" && method !== "PUT") {
    next();
    return;
  }

  var headers = request.headers;

  // These methods support document body.  Create body or multipart.
  headers["content-type"] = headers["content-type"] || "application/x-www-form-urlencoded";
  var mimeType = headers["content-type"].split(";")[0];
  if (request.body) {
    next();
    return;
  }

  var params = request.params || {};
  switch (mimeType) {
    case "application/x-www-form-urlencoded":
      {
        request.body = QS.stringify(params);
        headers["content-length"] = request.body.length;
        next();
        break;
      }

    case "multipart/form-data":
      {
        if (_core.Object.keys(params).length === 0) {
          // Empty parameters, can't use multipart
          headers["content-type"] = "text/plain";
          request.body = "";
        } else {

          var boundary = "" + new Date().getTime() + "." + Math.random();
          headers["content-type"] += "; boundary=" + boundary;
          request.multipart = _core.Object.keys(params).reduce(function (parts, name) {
            var values = params[name].map(function (value) {
              return formData(name, value);
            });
            return parts.concat(values);
          }, []);
        }
        next();
        break;
      }

    case "text/plain":
      {
        // XHR requests use this by default
        next();
        break;
      }

    default:
      {
        next(new Error("Unsupported content type " + mimeType));
        break;
      }
  }
};

function formData(name, value) {
  if (value.read) {
    var buffer = value.read();
    return {
      "Content-Disposition": "form-data; name=\"" + name + "\"; filename=\"" + value + "\"",
      "Content-Type": value.mime || "application/octet-stream",
      "Content-Length": buffer.length,
      body: buffer
    };
  } else {
    return {
      "Content-Disposition": "form-data; name=\"" + name + "\"",
      "Content-Type": "text/plain; charset=utf8",
      "Content-Length": value.length,
      body: value
    };
  }
}

Resources.handleHTTPResponse = function (request, response, next) {
  response.headers = response.headers || {};

  var _URL$parse = URL.parse(request.url);

  var protocol = _URL$parse.protocol;
  var hostname = _URL$parse.hostname;
  var pathname = _URL$parse.pathname;

  if (protocol !== "http:" && protocol !== "https:") {
    next();
    return;
  }

  // Set cookies from response
  var setCookie = response.headers["set-cookie"];
  if (setCookie) this.cookies.update(setCookie, hostname, pathname);

  // Number of redirects so far.
  var redirects = request.redirects || 0;
  var redirectUrl = null;

  // Determine whether to automatically redirect and which method to use
  // based on the status code
  var statusCode = response.statusCode;

  if (statusCode === 301 || statusCode === 307) {
    // Do not follow POST redirects automatically, only GET/HEAD
    if (request.method === "GET" || request.method === "HEAD") redirectUrl = URL.resolve(request.url, response.headers.location || "");
  } else if (statusCode === 302 || statusCode === 303) {
    // Follow redirect using GET (e.g. after form submission)
    redirectUrl = URL.resolve(request.url, response.headers.location || "");
  }

  if (redirectUrl) {

    response.url = redirectUrl;
    // Handle redirection, make sure we're not caught in an infinite loop
    ++redirects;
    if (redirects > this.maxRedirects) {
      next(new Error("More than " + this.maxRedirects + " redirects, giving up"));
      return;
    }

    var redirectHeaders = _core.Object.assign({}, request.headers);
    // This request is referer for next
    redirectHeaders.referer = request.url;
    // These headers exist in POST request, do not pass to redirect (GET)
    delete redirectHeaders["content-type"];
    delete redirectHeaders["content-length"];
    delete redirectHeaders["content-transfer-encoding"];
    // Redirect must follow the entire chain of handlers.
    var redirectRequest = {
      method: "GET",
      url: response.url,
      headers: redirectHeaders,
      redirects: redirects,
      strictSSL: request.strictSSL,
      time: request.time,
      timeout: request.timeout
    };
    this.emit("redirect", request, response, redirectRequest);
    this.resources.runPipeline(redirectRequest, next);
  } else {
    response.redirects = redirects;
    next();
  }
};

// Handle deflate and gzip transfer encoding.
Resources.decompressBody = function (request, response, next) {
  var transferEncoding = response.headers["transfer-encoding"];
  var contentEncoding = response.headers["content-encoding"];
  if (contentEncoding === "deflate" || transferEncoding === "deflate") {
    Zlib.inflate(response.body, function (error, buffer) {
      response.body = buffer;
      next(error);
    });
  } else if (contentEncoding === "gzip" || transferEncoding === "gzip") {
    Zlib.gunzip(response.body, function (error, buffer) {
      response.body = buffer;
      next(error);
    });
  } else next();
};

// Find the charset= value of the meta tag
var MATCH_CHARSET = /<meta(?!\s*(?:name|value)\s*=)[^>]*?charset\s*=[\s"']*([^\s"'\/>]*)/i;

// This handler decodes the response body based on the response content type.
Resources.decodeBody = function (request, response, next) {
  if (!Buffer.isBuffer(response.body)) {
    next();
    return;
  }

  // If Content-Type header specifies charset, use that
  var contentType = response.headers["content-type"] || "application/unknown";

  var _contentType$split = contentType.split(/;\s*/);

  var _contentType$split2 = _toArray(_contentType$split);

  var mimeType = _contentType$split2[0];

  var typeOptions = _contentType$split2.slice(1);

  var _contentType$split3 = contentType.split(/\//, 2);

  var _contentType$split32 = _slicedToArray(_contentType$split3, 2);

  var type = _contentType$split32[0];
  var subtype = _contentType$split32[1];

  // Images, binary, etc keep response body a buffer
  if (type && type !== "text") {
    next();
    return;
  }

  var charset = null;

  // Pick charset from content type
  if (mimeType) {
    for (var _iterator = typeOptions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var typeOption = _ref;

      if (/^charset=/i.test(typeOption)) {
        charset = typeOption.split("=")[1];
        break;
      }
    }
  }

  // Otherwise, HTML documents only, pick charset from meta tag
  // Otherwise, HTML documents only, default charset in US is windows-1252
  var isHTML = /html/.test(subtype) || /\bhtml\b/.test(request.headers.accept);
  if (!charset && isHTML) {
    var match = response.body.toString().match(MATCH_CHARSET);
    charset = match ? match[1] : "windows-1252";
  }

  if (charset) response.body = iconv.decode(response.body, charset);
  next();
};

// All browsers start out with this list of handler.
Resources.pipeline = [Resources.normalizeURL, Resources.mergeHeaders, Resources.createBody, Resources.handleHTTPResponse, Resources.decompressBody, Resources.decodeBody];

// -- Make HTTP request

// Used to perform HTTP request (also supports file: resources).  This is always
// the last request handler.
Resources.makeHTTPRequest = function (request, callback) {
  var _URL$parse = URL.parse(request.url);

  var protocol = _URL$parse.protocol;
  var hostname = _URL$parse.hostname;
  var pathname = _URL$parse.pathname;

  if (protocol === "file:") {
    var _ret = (function () {

      // If the request is for a file:// descriptor, just open directly from the
      // file system rather than getting node's http (which handles file://
      // poorly) involved.
      if (request.method !== "GET") {
        callback(null, { statusCode: 405 });
        return {
          v: undefined
        };
      }

      var filename = Path.normalize(decodeURI(pathname));
      File.exists(filename, function (exists) {
        if (exists) {
          File.readFile(filename, function (error, buffer) {
            // Fallback with error -> callback
            if (error) {
              request.error = error;
              callback(error);
            } else callback(null, { body: buffer });
          });
        } else callback(null, { statusCode: 404 });
      });
    })();

    if (typeof _ret === "object") return _ret.v;
  } else {

    // We're going to use cookies later when recieving response.

    var _ref = this;

    var cookies = _ref.cookies;

    request.headers.cookie = cookies.serialize(hostname, pathname);

    var httpRequest = {
      method: request.method,
      url: request.url,
      headers: request.headers,
      body: request.body,
      multipart: request.multipart,
      proxy: this.proxy,
      jar: false,
      followRedirect: false,
      encoding: null,
      strictSSL: request.strictSSL,
      localAddress: request.localAddress || 0,
      timeout: request.timeout || 0
    };

    Request(httpRequest, function (error, response) {
      if (error) {
        callback(error);
      } else {
        callback(null, {
          url: request.url,
          statusCode: response.statusCode,
          headers: response.headers,
          body: response.body,
          redirects: request.redirects || 0
        });
      }
    });
  }
};

module.exports = Resources;
//# sourceMappingURL=resources.js.map