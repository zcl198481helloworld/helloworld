"use strict";

var _classCallCheck = require("babel-runtime/helpers/class-call-check")["default"];

var _inherits = require("babel-runtime/helpers/inherits")["default"];

var _createClass = require("babel-runtime/helpers/create-class")["default"];

var _toConsumableArray = require("babel-runtime/helpers/to-consumable-array")["default"];

var _slicedToArray = require("babel-runtime/helpers/sliced-to-array")["default"];

var _core = require("babel-runtime/core-js")["default"];

var assert = require("assert");
var Assert = require("./assert");
var Bluebird = require("bluebird");
var Tabs = require("./tabs");
var Console = require("./console");
var Cookies = require("./cookies");
var debug = require("debug");
var DOM = require("./dom");

var _require = require("events");

var EventEmitter = _require.EventEmitter;

var EventLoop = require("./eventloop");

var _require2 = require("util");

var format = _require2.format;

var File = require("fs");
var Mime = require("mime");
var ms = require("ms");
var Path = require("path");
var reroute = require("./reroute");
var Resources = require("./resources");
var Storages = require("./storage");
var Tough = require("tough-cookie");
var Cookie = Tough.Cookie;

var URL = require("url");

// Version number.  We get this from package.json.
var VERSION = require("" + __dirname + "/../package.json").version;

// Browser options you can set when creating new browser, or on browser instance.
var BROWSER_OPTIONS = ["features", "headers", "waitDuration", "proxy", "referrer", "silent", "site", "strictSSL", "userAgent", "maxRedirects", "language", "runScripts", "localAddress"];

// Supported browser features.
var BROWSER_FEATURES = ["scripts", "css", "img", "iframe"];
// These features are set on/off by default.
// Note that default values are actually prescribed where they are used,
// by calling hasFeature with name and default
var DEFAULT_FEATURES = "scripts no-css no-img iframe";

var MOUSE_EVENT_NAMES = ["mousedown", "mousemove", "mouseup"];

// Use the browser to open up new windows and load documents.
//
// The browser maintains state for cookies and local storage.

var Browser = (function (_EventEmitter) {
  function Browser() {
    var _this = this;

    var options = arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Browser);

    // Used for assertions
    this.assert = new Assert(this);
    this.cookies = new Cookies();
    // Shared by all windows.
    this.console = new Console(this);
    // Start with no this referrer.
    this.referrer = null;
    // All the resources loaded by this browser.
    this.resources = new Resources(this);
    // Open tabs.
    this.tabs = new Tabs(this);
    // The browser event loop.
    this.eventLoop = new EventLoop(this);

    // Returns all errors reported while loading this window.
    this.errors = [];

    this._storages = new Storages();

    // The window that is currently in scope, some JS functions need this, e.g.
    // when closing a window, you need to determine whether caller (window in
    // scope) is same as window.opener
    this._windowInScope = null;

    this._debug = Browser._debug;

    // Message written to window.console.  Level is log, info, error, etc.
    //
    // All output goes to stdout, except when browser.silent = true and output
    // only shown when debugging (DEBUG=zombie).
    this.on("console", function (level, message) {
      if (_this.silent) _this._debug(">> " + message);else console.log(message);
    }).on("log", function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Message written to browser.log.
      _this._debug(format.apply(undefined, args));
    });

    // Logging resources
    this.on("request", function (request) {
      return request;
    }).on("response", function (request, response) {
      _this._debug("%s %s => %s", request.method, response.url, response.statusCode);
    }).on("redirect", function (request, response, redirectRequest) {
      _this._debug("%s %s => %s %s", request.method, request.url, response.statusCode, redirectRequest.url);
    }).on("loaded", function (document) {
      _this._debug("Loaded document %s", document.location.href);
    }).on("xhr", function (eventName, url) {
      _this._debug("XHR %s %s", eventName, url);
    });

    // Logging windows/tabs/navigation
    this.on("opened", function (window) {
      _this._debug("Opened window %s %s", window.location.href, window.name || "");
    }).on("closed", function (window) {
      _this._debug("Closed window %s %s", window.location.href, window.name || "");
    });

    // Switching tabs/windows fires blur/focus event on active window/element
    this.on("active", function (window) {
      // Window becomes inactive
      var winFocus = window.document.createEvent("HTMLEvents");
      winFocus.initEvent("focus", false, false);
      window.dispatchEvent(winFocus);

      if (window.document.activeElement) {
        var elemFocus = window.document.createEvent("HTMLEvents");
        elemFocus.initEvent("focus", false, false);
        window.document.activeElement.dispatchEvent(elemFocus);
      }
    }).on("inactive", function (window) {
      // Window becomes inactive
      if (window.document.activeElement) {
        var elemBlur = window.document.createEvent("HTMLEvents");
        elemBlur.initEvent("blur", false, false);
        window.document.activeElement.dispatchEvent(elemBlur);
      }
      var winBlur = window.document.createEvent("HTMLEvents");
      winBlur.initEvent("blur", false, false);
      window.dispatchEvent(winBlur);
    });

    // Logging navigation
    this.on("link", function (url, target) {
      _this._debug("Follow link to %s", url);
    }).on("submit", function (url, target) {
      _this._debug("Submit form to %s", url);
    });

    // Logging event loop
    this.eventLoop.on("setTimeout", function (fn, delay) {
      _this._debug("Fired setTimeout after %dms delay", delay);
      _this.emit("setTimeout", fn, delay);
    }).on("setInterval", function (fn, interval) {
      _this._debug("Fired setInterval every %dms", interval);
      _this.emit("setInterval", fn, interval);
    }).on("serverEvent", function () {
      _this._debug("Server initiated event");
      _this.emit("serverEvent");
    }).on("idle", function (timedOut) {
      if (timedOut) _this._debug("Event loop timed out");else _this._debug("Event loop is empty");
      _this.emit("idle");
    }).on("error", function (error) {
      _this.emit("error", error);
    });

    // Make sure we don't blow up Node when we get a JS error, but dump error to console.  Also, catch any errors
    // reported while processing resources/JavaScript.
    this.on("error", function (error) {
      _this.errors.push(error);
      _this._debug(error.stack);
    });

    // Sets the browser options.
    options = options || {};
    for (var _iterator = BROWSER_OPTIONS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var _name = _ref;

      this[_name] = options.hasOwnProperty(_name) ? options[_name] : Browser[_name];
    } // Last, run all extensions in order.
    for (var _iterator2 = Browser._extensions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var extension = _ref2;

      extension(this);
    }
  }

  _inherits(Browser, _EventEmitter);

  // Returns true if the given feature is enabled.
  //
  // If the feature is listed, then it is enabled.  If the feature is listed
  // with "no-" prefix, then it is disabled.  If the feature is missing, return
  // the default value.

  Browser.prototype.hasFeature = function hasFeature(name) {
    var defaultValue = arguments[1] === undefined ? true : arguments[1];

    var features = (this.features || "").split(/\s+/);
    return ~features.indexOf(name) ? true : ~features.indexOf("no-" + name) ? false : defaultValue;
  };

  // Return a new browser with a snapshot of this browser's state.
  // Any changes to the forked browser's state do not affect this browser.

  Browser.prototype.fork = function fork() {
    throw new Error("Not implemented");
  };

  // Open new browser window.

  Browser.prototype.open = function open() {
    var _ref = arguments[0] === undefined ? {} : arguments[0];

    var url = _ref.url;
    var name = _ref.name;
    var referrer = _ref.referrer;

    return this.tabs.open({ url: url, name: name, referrer: referrer });
  };

  // Events
  // ------

  // Waits for the browser to complete loading resources and processing JavaScript events.
  //
  // Accepts two parameters, both optional:
  // options   - Options that determine how long to wait (see below)
  // callback  - Called with error or null and browser
  //
  // To determine how long to wait:
  // duration  - Do not wait more than this duration (milliseconds or string of
  //             the form "5s"). Defaults to "5s" (see Browser.waitDuration).
  // element   - Stop when this element(s) appear in the DOM.
  // function  - Stop when function returns true; this function is called with
  //             the active window and expected time to the next event (0 to
  //             Infinity).
  //
  // As a convenience you can also pass the duration directly.
  //
  // Without a callback, this method returns a promise.

  Browser.prototype.wait = function wait(options, callback) {
    assert(this.window, new Error("No window open"));
    if (arguments.length === 1 && typeof options === "function") {
      var _ref = [options, null];

      var _ref2 = _slicedToArray(_ref, 2);

      callback = _ref2[0];
      options = _ref2[1];
    }
    assert(!callback || typeof callback === "function", "Second argument expected to be a callback function or null");

    // Support all sort of shortcuts for options. Unofficial.
    var duration = typeof options === "number" ? options : typeof options === "string" ? options : options && options.duration || this.waitDuration || "5s";
    // Support 500 (ms) as well as "5s"
    var waitDuration = ms(duration.toString());

    var completionFunction = typeof options === "function" ? options : options && options.element ? completionFromElement(options.element) : options && options["function"];

    function completionFromElement(element) {
      return function (window) {
        return !!window.document.querySelector(element);
      };
    }

    var _ref3 = this;

    var eventLoop = _ref3.eventLoop;

    if (callback) {
      eventLoop.wait(waitDuration, completionFunction, callback);
    } else {
      return Bluebird.promisify(eventLoop.wait, eventLoop)(waitDuration, completionFunction);
    }
  };

  // Waits for the browser to get a single event from any EventSource,
  // then completes loading resources and processing JavaScript events.
  //
  // Accepts an optional callback which is called with error or nothing
  //
  // Without a callback, this method returns a promise.

  Browser.prototype.waitForServer = function waitForServer(options, callback) {
    var _this = this;

    assert(this.window, new Error("No window open"));
    if (arguments.length === 1 && typeof options === "function") {
      var _ref = [options, null];

      var _ref2 = _slicedToArray(_ref, 2);

      callback = _ref2[0];
      options = _ref2[1];
    }

    if (callback) {
      this.eventLoop.once("serverEvent", function () {
        _this.wait(options, callback);
      });
    } else {
      return new Bluebird(function (resolve) {
        _this.eventLoop.once("serverEvent", function () {
          resolve(_this.wait(options, null));
        });
      });
    }
  };

  // Various methods use this with a callback, or return a lazy promise (e.g.
  // visit, click, fire)

  Browser.prototype._wait = function _wait(options, callback) {
    var _this = this;

    if (callback) {
      this.wait(options, callback);
    } else {
      var _ret = (function () {
        var promise = null;
        var lazyResolve = function () {
          if (!promise) promise = _this.wait(options, null);
          return promise;
        };
        // Returns equivalent of a promise that only starts evaluating when you
        // call then() or catch() on it.
        return {
          v: {
            then: function then(resolved, rejected) {
              return lazyResolve().then(resolved, rejected);
            },
            "catch": function _catch(rejected) {
              return lazyResolve().then(null, rejected);
            } }
        };
      })();

      if (typeof _ret === "object") {
        return _ret.v;
      }
    }
  };

  // Fire a DOM event.  You can use this to simulate a DOM event, e.g. clicking
  // a link.  These events will bubble up and can be cancelled.  Like `wait`
  // this method takes an optional callback and returns a promise.
  //
  // name - Even name (e.g `click`)
  // target - Target element (e.g a link)
  // callback - Called with error or nothing
  //
  // If called without callback, returns a promsie

  Browser.prototype.fire = function fire(selector, eventName, callback) {
    assert(this.window, "No window open");
    var target = this.query(selector);
    assert(target && target.dispatchEvent, "No target element (note: call with selector/element, event name and callback)");

    var eventType = ~MOUSE_EVENT_NAMES.indexOf(eventName) ? "MouseEvents" : "HTMLEvents";
    var event = this.document.createEvent(eventType);
    event.initEvent(eventName, true, true);
    target.dispatchEvent(event);
    return this._wait(null, callback);
  };

  // Click on the element and returns a promise.
  //
  // selector - Element or CSS selector
  // callback - Called with error or nothing
  //
  // If called without callback, returns a promsie

  Browser.prototype.click = function click(selector, callback) {
    return this.fire(selector, "click", callback);
  };

  // Dispatch asynchronously.  Returns true if preventDefault was set.

  Browser.prototype.dispatchEvent = function dispatchEvent(selector, event) {
    assert(this.window, "No window open");
    var target = this.query(selector);
    return target.dispatchEvent(event);
  };

  // Accessors
  // ---------

  // browser.queryAll(selector, context?) => Array
  //
  // Evaluates the CSS selector against the document (or context node) and return array of nodes.
  // (Unlike `document.querySelectorAll` that returns a node list).

  Browser.prototype.queryAll = function queryAll() {
    var selector = arguments[0] === undefined ? "html" : arguments[0];
    var context = arguments[1] === undefined ? this.document : arguments[1];

    assert(this.document && this.document.documentElement, "No open window with an HTML document");

    if (Array.isArray(selector)) {
      return selector;
    }if (selector instanceof DOM.Element) {
      return [selector];
    }if (selector) {
      var elements = context.querySelectorAll(selector);
      return [].concat(_toConsumableArray(elements));
    } else {
      return [];
    }
  };

  // browser.query(selector, context?) => Element
  //
  // Evaluates the CSS selector against the document (or context node) and return an element.

  Browser.prototype.query = function query() {
    var selector = arguments[0] === undefined ? "html" : arguments[0];
    var context = arguments[1] === undefined ? this.document : arguments[1];

    assert(this.document && this.document.documentElement, "No open window with an HTML document");

    if (selector instanceof DOM.Element) {
      return selector;
    }return selector ? context.querySelector(selector) : context;
  };

  // WebKit offers this.

  Browser.prototype.$$ = function $$(selector, context) {
    return this.query(selector, context);
  };

  // browser.querySelector(selector) => Element
  //
  // Select a single element (first match) and return it.
  //
  // selector - CSS selector
  //
  // Returns an Element or null

  Browser.prototype.querySelector = function querySelector(selector) {
    assert(this.document && this.document.documentElement, "No open window with an HTML document");
    return this.document.querySelector(selector);
  };

  // browser.querySelectorAll(selector) => NodeList
  //
  // Select multiple elements and return a static node list.
  //
  // selector - CSS selector
  //
  // Returns a NodeList or null

  Browser.prototype.querySelectorAll = function querySelectorAll(selector) {
    assert(this.document && this.document.documentElement, "No open window with an HTML document");
    return this.document.querySelectorAll(selector);
  };

  // browser.text(selector, context?) => String
  //
  // Returns the text contents of the selected elements.
  //
  // selector - CSS selector (if missing, entire document)
  // context - Context element (if missing, uses document)
  //
  // Returns a string

  Browser.prototype.text = function text() {
    var selector = arguments[0] === undefined ? "html" : arguments[0];
    var context = arguments[1] === undefined ? this.document : arguments[1];

    assert(this.document, "No window open");

    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function (elem) {
        return elem.textContent;
      }).join("").trim().replace(/\s+/g, " ");
    } else {
      return this.source ? this.source.toString : "";
    }
  };

  // browser.html(selector?, context?) => String
  //
  // Returns the HTML contents of the selected elements.
  //
  // selector - CSS selector (if missing, entire document)
  // context - Context element (if missing, uses document)
  //
  // Returns a string

  Browser.prototype.html = function html() {
    var selector = arguments[0] === undefined ? "html" : arguments[0];
    var context = arguments[1] === undefined ? this.document : arguments[1];

    assert(this.document, "No window open");

    if (this.document.documentElement) {
      return this.queryAll(selector, context).map(function (elem) {
        return elem.outerHTML.trim();
      }).join("");
    } else {
      return this.source ? this.source.toString : "";
    }
  };

  // browser.xpath(expression, context?) => XPathResult
  //
  // Evaluates the XPath expression against the document (or context node) and return the XPath result.  Shortcut for
  // `document.evaluate`.

  Browser.prototype.xpath = function xpath(expression) {
    var context = arguments[1] === undefined ? null : arguments[1];

    return this.document.evaluate(expression, context || this.document.documentElement, null, DOM.XPathResult.ANY_TYPE);
  };

  // Close the currently open tab, or the tab opened to the specified window.

  Browser.prototype.close = function close(window) {
    this.tabs.close(window);
  };

  // done
  //
  // Close all windows, clean state. You're going to need to call this to free up memory.

  Browser.prototype.destroy = function destroy() {
    if (this.tabs) {
      this.tabs.closeAll();
      this.tabs = null;
    }
  };

  // Navigation
  // ----------

  // browser.visit(url, callback?)
  //
  // Loads document from the specified URL, processes events and calls the callback, or returns a promise.

  Browser.prototype.visit = function visit(url, options, callback) {
    if (arguments.length < 3 && typeof options === "function") {
      var _ref = [{}, options];

      var _ref2 = _slicedToArray(_ref, 2);

      options = _ref2[0];
      callback = _ref2[1];
    }

    var site = /^(https?:|file:)/i.test(this.site) ? this.site : "http://" + (this.site || "localhost") + "/";
    url = URL.resolve(site, URL.parse(URL.format(url)));

    if (this.window) this.tabs.close(this.window);
    this.errors = [];
    this.tabs.open({ url: url, referrer: this.referrer });
    return this._wait(options, callback);
  };

  // browser.load(html, callback)
  //
  // Loads the HTML, processes events and calls the callback.
  //
  // Without a callback, returns a promise.

  Browser.prototype.load = function load(html, callback) {
    if (this.window) this.tabs.close(this.window);
    this.errors = [];
    this.tabs.open({ html: html });
    return this._wait(null, callback);
  };

  // browser.link(selector) : Element
  //
  // Finds and returns a link by its text content or selector.

  Browser.prototype.link = function link(selector) {
    assert(this.document && this.document.documentElement, "No open window with an HTML document");
    // If the link has already been queried, return itself
    if (selector instanceof DOM.Element) {
      return selector;
    }try {
      var link = this.querySelector(selector);
      if (link && link.tagName === "A") return link;
    } catch (error) {}
    for (var _iterator = [].concat(_toConsumableArray(this.querySelectorAll("body a"))), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var elem = _ref;

      if (elem.textContent.trim() === selector) {
        return elem;
      }
    }
    return null;
  };

  // browser.clickLink(selector, callback)
  //
  // Clicks on a link. Clicking on a link can trigger other events, load new page, etc: use a callback to be notified of
  // completion.  Finds link by text content or selector.
  //
  // selector - CSS selector or link text
  // callback - Called with two arguments: error and browser

  Browser.prototype.clickLink = function clickLink(selector, callback) {
    var link = this.link(selector);
    assert(link, "No link matching '" + selector + "'");
    return this.click(link, callback);
  };

  // Navigate back in history.

  Browser.prototype.back = function back(callback) {
    this.window.history.back();
    return this._wait(null, callback);
  };

  // Reloads current page.

  Browser.prototype.reload = function reload(callback) {
    this.window.location.reload();
    return this._wait(null, callback);
  };

  // browser.saveHistory() => String
  //
  // Save history to a text string.  You can use this to load the data later on using `browser.loadHistory`.

  Browser.prototype.saveHistory = function saveHistory() {
    this.window.history.save();
  };

  // browser.loadHistory(String)
  //
  // Load history from a text string (e.g. previously created using `browser.saveHistory`.

  Browser.prototype.loadHistory = function loadHistory(serialized) {
    this.window.history.load(serialized);
  };

  // Forms
  // -----

  // browser.field(selector) : Element
  //
  // Find and return an input field (`INPUT`, `TEXTAREA` or `SELECT`) based on a CSS selector, field name (its `name`
  // attribute) or the text value of a label associated with that field (case sensitive, but ignores leading/trailing
  // spaces).

  Browser.prototype.field = function field(selector) {
    assert(this.document && this.document.documentElement, "No open window with an HTML document");
    // If the field has already been queried, return itself
    if (selector instanceof DOM.Element) {
      return selector;
    }try {
      // Try more specific selector first.
      var field = this.query(selector);
      if (field && (field.tagName === "INPUT" || field.tagName === "TEXTAREA" || field.tagName === "SELECT")) return field;
    } catch (error) {}

    // Use field name (case sensitive).
    for (var _iterator = this.queryAll("input[name],textarea[name],select[name]"), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var elem = _ref;

      if (elem.getAttribute("name") === selector) {
        return elem;
      }
    }

    // Try finding field from label.
    for (var _iterator2 = this.queryAll("label"), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var label = _ref2;

      if (label.textContent.trim() === selector) {
        // nLabel can either reference field or enclose it
        var forAttr = label.getAttribute("for");
        return forAttr ? this.document.getElementById(forAttr) : label.querySelector("input,textarea,select");
      }
    }
    return null;
  };

  // browser.focus(selector) : Element
  //
  // Turns focus to the selected input field.  Shortcut for calling `field(selector).focus()`.

  Browser.prototype.focus = function focus(selector) {
    var field = this.field(selector) || this.query(selector);
    assert(field, "No form field matching '" + selector + "'");
    field.focus();
    return this;
  };

  // browser.fill(selector, value) => this
  //
  // Fill in a field: input field or text area.
  //
  // selector - CSS selector, field name or text of the field label
  // value - Field value
  //
  // Returns this.

  Browser.prototype.fill = function fill(selector, value) {
    var field = this.field(selector);
    assert(field && (field.tagName === "TEXTAREA" || field.tagName === "INPUT"), "No INPUT matching '" + selector + "'");
    assert(!field.getAttribute("disabled"), "This INPUT field is disabled");
    assert(!field.getAttribute("readonly"), "This INPUT field is readonly");

    // Switch focus to field, change value and emit the input event (HTML5)
    field.focus();
    field.value = value;
    this.fire(field, "input", false);
    // Switch focus out of field, if value changed, this will emit change event
    field.blur();
    return this;
  };

  Browser.prototype._setCheckbox = function _setCheckbox(selector, value) {
    var field = this.field(selector);
    assert(field && field.tagName === "INPUT" && field.type === "checkbox", "No checkbox INPUT matching '" + selector + "'");
    assert(!field.getAttribute("disabled"), "This INPUT field is disabled");
    assert(!field.getAttribute("readonly"), "This INPUT field is readonly");

    if (field.checked ^ value) field.click();
    return this;
  };

  // browser.check(selector) => this
  //
  // Checks a checkbox.
  //
  // selector - CSS selector, field name or text of the field label
  //
  // Returns this.

  Browser.prototype.check = function check(selector) {
    return this._setCheckbox(selector, true);
  };

  // browser.uncheck(selector) => this
  //
  // Unchecks a checkbox.
  //
  // selector - CSS selector, field name or text of the field label
  //
  // Returns this.

  Browser.prototype.uncheck = function uncheck(selector) {
    return this._setCheckbox(selector, false);
  };

  // browser.choose(selector) => this
  //
  // Selects a radio box option.
  //
  // selector - CSS selector, field value or text of the field label
  //
  // Returns this.

  Browser.prototype.choose = function choose(selector) {
    var field = this.field(selector) || this.field("input[type=radio][value='" + escape(selector) + "']");
    assert(field && field.tagName === "INPUT" && field.type === "radio", "No radio INPUT matching '" + selector + "'");

    field.click();
    return this;
  };

  Browser.prototype._findOption = function _findOption(selector, value) {
    var field = this.field(selector);
    assert(field && field.tagName === "SELECT", "No SELECT matching '" + selector + "'");
    assert(!field.getAttribute("disabled"), "This SELECT field is disabled");
    assert(!field.getAttribute("readonly"), "This SELECT field is readonly");

    var options = [].concat(_toConsumableArray(field.options));
    for (var _iterator = options, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var option = _ref;

      if (option.value === value) {
        return option;
      }
    }
    for (var _iterator2 = options, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var option = _ref2;

      if (option.label === value) {
        return option;
      }
    }
    for (var _iterator3 = options, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.$for.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var option = _ref3;

      if (option.textContent.trim() === value) {
        return option;
      }
    }
    throw new Error("No OPTION '" + value + "'");
  };

  // browser.select(selector, value) => this
  //
  // Selects an option.
  //
  // selector - CSS selector, field name or text of the field label
  // value - Value (or label) or option to select
  //
  // Returns this.

  Browser.prototype.select = function select(selector, value) {
    var option = this._findOption(selector, value);
    this.selectOption(option);
    return this;
  };

  // browser.selectOption(option) => this
  //
  // Selects an option.
  //
  // option - option to select
  //
  // Returns this.

  Browser.prototype.selectOption = function selectOption(selector) {
    var option = this.query(selector);
    if (option && !option.getAttribute("selected")) {
      var select = this.xpath("./ancestor::select", option).iterateNext();
      option.setAttribute("selected", "selected");
      select.focus();
      this.fire(select, "change", false);
    }
    return this;
  };

  // browser.unselect(selector, value) => this
  //
  // Unselects an option.
  //
  // selector - CSS selector, field name or text of the field label
  // value - Value (or label) or option to unselect
  //
  // Returns this.

  Browser.prototype.unselect = function unselect(selector, value) {
    var option = this._findOption(selector, value);
    this.unselectOption(option);
    return this;
  };

  // browser.unselectOption(option) => this
  //
  // Unselects an option.
  //
  // selector - selector or option to unselect
  //
  // Returns this.

  Browser.prototype.unselectOption = function unselectOption(selector) {
    var option = this.query(selector);
    if (option && option.getAttribute("selected")) {
      var select = this.xpath("./ancestor::select", option).iterateNext();
      assert(select.multiple, "Cannot unselect in single select");
      option.removeAttribute("selected");
      select.focus();
      this.fire(select, "change", false);
    }
    return this;
  };

  // browser.attach(selector, filename) => this
  //
  // Attaches a file to the specified input field.  The second argument is the file name.
  //
  // Returns this.

  Browser.prototype.attach = function attach(selector, filename) {
    var field = this.field(selector);
    assert(field && field.tagName === "INPUT" && field.type === "file", "No file INPUT matching '" + selector + "'");

    if (filename) {
      var stat = File.statSync(filename);
      var file = new this.window.File();
      file.name = Path.basename(filename);
      file.type = Mime.lookup(filename);
      file.size = stat.size;

      field.value = filename;
      field.files = field.files || [];
      field.files.push(file);
    }
    field.focus();
    this.fire(field, "change", false);
    return this;
  };

  // browser.button(selector) : Element
  //
  // Finds a button using CSS selector, button name or button text (`BUTTON` or `INPUT` element).
  //
  // selector - CSS selector, button name or text of BUTTON element

  Browser.prototype.button = function button(selector) {
    assert(this.document && this.document.documentElement, "No open window with an HTML document");
    // If the button has already been queried, return itself
    if (selector instanceof DOM.Element) {
      return selector;
    }try {
      var button = this.querySelector(selector);
      if (button && (button.tagName === "BUTTON" || button.tagName === "INPUT")) return button;
    } catch (error) {}
    for (var _iterator = [].concat(_toConsumableArray(this.querySelectorAll("button"))), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var elem = _ref;

      if (elem.textContent.trim() === selector) {
        return elem;
      }
    }

    var inputs = [].concat(_toConsumableArray(this.querySelectorAll("input[type=submit],button")));
    for (var _iterator2 = inputs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.$for.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var input = _ref2;

      if (input.name === selector) {
        return input;
      }
    }
    for (var _iterator3 = inputs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.$for.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var input = _ref3;

      if (input.value === selector) {
        return input;
      }
    }
    return null;
  };

  // browser.pressButton(selector, callback)
  //
  // Press a button (button element or input of type `submit`).  Typically this will submit the form.  Use the callback
  // to wait for the from submission, page to load and all events run their course.
  //
  // selector - CSS selector, button name or text of BUTTON element
  // callback - Called with two arguments: null and browser

  Browser.prototype.pressButton = function pressButton(selector, callback) {
    var button = this.button(selector);
    assert(button, "No BUTTON '" + selector + "'");
    assert(!button.getAttribute("disabled"), "This button is disabled");
    button.focus();
    return this.fire(button, "click", callback);
  };

  // -- Cookies --

  // Returns cookie that best matches the identifier.
  //
  // identifier - Identifies which cookie to return
  // allProperties - If true, return all cookie properties, other just the value
  //
  // Identifier is either the cookie name, in which case the cookie domain is
  // determined from the currently open Web page, and the cookie path is "/".
  //
  // Or the identifier can be an object specifying:
  // name   - The cookie name
  // domain - The cookie domain (defaults to hostname of currently open page)
  // path   - The cookie path (defaults to "/")
  //
  // Returns cookie value, or cookie object (see setCookie).

  Browser.prototype.getCookie = function getCookie(identifier, allProperties) {
    identifier = this._cookieIdentifier(identifier);
    assert(identifier.name, "Missing cookie name");
    assert(identifier.domain, "No domain specified and no open page");

    var cookie = this.cookies.select(identifier)[0];
    return cookie ? allProperties ? this._cookieProperties(cookie) : cookie.value : null;
  };

  // Deletes cookie that best matches the identifier.
  //
  // identifier - Identifies which cookie to return
  //
  // Identifier is either the cookie name, in which case the cookie domain is
  // determined from the currently open Web page, and the cookie path is "/".
  //
  // Or the identifier can be an object specifying:
  // name   - The cookie name
  // domain - The cookie domain (defaults to hostname of currently open page)
  // path   - The cookie path (defaults to "/")
  //
  // Returns true if cookie delete.

  Browser.prototype.deleteCookie = function deleteCookie(identifier) {
    identifier = this._cookieIdentifier(identifier);
    assert(identifier.name, "Missing cookie name");
    assert(identifier.domain, "No domain specified and no open page");

    var cookie = this.cookies.select(identifier)[0];
    if (cookie) this.cookies["delete"](cookie);
    return !!cookie;
  };

  // Sets a cookie.
  //
  // You can call this function with two arguments to set a session cookie: the
  // cookie value and cookie name.  The domain is determined from the current
  // page URL, and the path is always "/".
  //
  // Or you can call it with a single argument, with all cookie options:
  // name     - Name of the cookie
  // value    - Value of the cookie
  // domain   - The cookie domain (e.g example.com, .example.com)
  // path     - The cookie path
  // expires  - Time when cookie expires
  // maxAge   - How long before cookie expires
  // secure   - True for HTTPS only cookie
  // httpOnly - True if cookie not accessible from JS

  Browser.prototype.setCookie = function setCookie(nameOrOptions, value) {
    var domain = this.location && this.location.hostname;
    if (typeof nameOrOptions === "string") {
      this.cookies.set({
        name: nameOrOptions,
        value: value || "",
        domain: domain,
        path: "/",
        secure: false,
        httpOnly: false
      });
    } else {
      assert(nameOrOptions.name, "Missing cookie name");
      this.cookies.set({
        name: nameOrOptions.name,
        value: nameOrOptions.value || value || "",
        domain: nameOrOptions.domain || domain,
        path: nameOrOptions.path || "/",
        secure: !!nameOrOptions.secure,
        httpOnly: !!nameOrOptions.httpOnly,
        expires: nameOrOptions.expires,
        "max-age": nameOrOptions["max-age"]
      });
    }
  };

  // Deletes all cookies.

  Browser.prototype.deleteCookies = function deleteCookies() {
    this.cookies.deleteAll();
  };

  // Save cookies to a text string.  You can use this to load them back
  // later on using `Browser.loadCookies`.

  Browser.prototype.saveCookies = function saveCookies() {
    var serialized = ["# Saved on " + new Date().toISOString()];
    for (var _iterator = this.cookies.sort(Tough.cookieCompare), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var cookie = _ref;

      serialized.push(cookie.toString());
    }return serialized.join("\n") + "\n";
  };

  // Load cookies from a text string (e.g. previously created using
  // `Browser.saveCookies`.

  Browser.prototype.loadCookies = function loadCookies(serialized) {
    for (var _iterator = serialized.split(/\n+/), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.$for.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var line = _ref;

      line = line.trim();
      if (line && line[0] !== "#") this.cookies.push(Cookie.parse(line));
    }
  };

  // Converts Tough Cookie object into Zombie cookie representation.

  Browser.prototype._cookieProperties = function _cookieProperties(cookie) {
    var properties = {
      name: cookie.key,
      value: cookie.value,
      domain: cookie.domain,
      path: cookie.path
    };
    if (cookie.secure) properties.secure = true;
    if (cookie.httpOnly) properties.httpOnly = true;
    if (cookie.expires && cookie.expires < Infinity) properties.expires = cookie.expires;
    return properties;
  };

  // Converts cookie name/identifier into an identifier object.

  Browser.prototype._cookieIdentifier = function _cookieIdentifier(identifier) {
    var location = this.location;
    var domain = location && location.hostname;
    var path = location && location.pathname || "/";
    return {
      name: identifier.name || identifier,
      domain: identifier.domain || domain,
      path: identifier.path || path
    };
  };

  // -- Local/Session Storage --

  // Returns local Storage based on the document origin (hostname/port). This is the same storage area you can access
  // from any document of that origin.

  Browser.prototype.localStorage = function localStorage(host) {
    return this._storages.local(host);
  };

  // Returns session Storage based on the document origin (hostname/port). This is the same storage area you can access
  // from any document of that origin.

  Browser.prototype.sessionStorage = function sessionStorage(host) {
    return this._storages.session(host);
  };

  // Save local/session storage to a text string.  You can use this to load the data later on using
  // `browser.loadStorage`.

  Browser.prototype.saveStorage = function saveStorage() {
    this._storages.save();
  };

  // Load local/session stroage from a text string (e.g. previously created using `browser.saveStorage`.

  Browser.prototype.loadStorage = function loadStorage(serialized) {
    this._storages.load(serialized);
  };

  // Scripts
  // -------

  // Evaluates a JavaScript expression in the context of the current window and returns the result.  When evaluating
  // external script, also include filename.
  //
  // You can also use this to evaluate a function in the context of the window: for timers and asynchronous callbacks
  // (e.g. XHR).

  Browser.prototype.evaluate = function evaluate(code, filename) {
    if (!this.window) this.open();
    return this.window._evaluate(code, filename);
  };

  // Debugging
  // ---------

  // Enable debugging.  You can do this in code instead of setting DEBUG environment variable.

  Browser.prototype.debug = function debug() {
    this._debug = Browser._enableDebugging();
  };

  // Zombie can spit out messages to help you figure out what's going on as your code executes.
  //
  // To spit a message to the console when running in debug mode, call this method with one or more values (same as
  // `console.log`).  You can also call it with a function that will be evaluated only when running in debug mode.
  //
  // For example:
  //     browser.log('Opening page:', url);
  //     browser.log(function() { return 'Opening page: ' + url });

  Browser.prototype.log = function log() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === "function") args = [args[0]()];
    this.emit("log", format.apply(undefined, args));
  };

  // Dump information to the console: Zombie version, current URL, history, cookies, event loop, etc.  Useful for
  // debugging and submitting error reports.

  Browser.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    function indent(lines) {
      return lines.map(function (line) {
        return "  " + line + "\n";
      }).join("");
    }
    output.write("Zombie: " + Browser.VERSION + "\n");
    output.write("URL:    " + this.window.location.href + "\n");
    output.write("\nHistory:\n");
    this.history.dump(output);
    output.write("\nCookies:\n");
    this.cookies.dump(output);
    output.write("\nStorage:\n");

    if (this.document) {
      var html = this.html();
      var slice = html.length > 497 ? "" + html.slice(0, 497) + "..." : html;
      output.write("Document:\n" + indent(slice.split("\n")) + "\n");
    } else output.write("No document\n");

    output.write("\n");
    this.eventLoop.dump(output);
  };

  // -- Static methods ---

  // ### zombie.visit(url, callback)
  // ### zombie.visit(url, options? callback)
  //
  // Creates a new Browser, opens window to the URL and calls the callback when
  // done processing all events.
  //
  // * url -- URL of page to open
  // * callback -- Called with error, browser

  Browser.visit = function visit(url, options, callback) {
    if (arguments.length === 2 && typeof options === "function") {
      var _ref = [null, options];

      var _ref2 = _slicedToArray(_ref, 2);

      options = _ref2[0];
      callback = _ref2[1];
    }
    var browser = new Browser(options);
    if (callback) browser.visit(url, function (error) {
      return callback(error, browser);
    });else {
      return browser.visit(url).then(function () {
        return browser;
      });
    }
  };

  // Use this function to create a new Browser instance.

  Browser.create = function create(options) {
    return new Browser(options);
  };

  // Allows you to make requests against a named domain and HTTP/S port, and
  // will route it to the test server running on localhost and unprivileged
  // port.

  Browser.localhost = function localhost(source, target) {
    reroute(source, target);
    if (!this.site) {
      var _source$split = source.split(":");

      var _source$split2 = _slicedToArray(_source$split, 1);

      var hostname = _source$split2[0];

      this.site = hostname.replace(/^\*\./, "");
    }
  };

  // Register a browser extension.
  //
  // Browser extensions are called for each newly created browser object, and
  // can be used to change browser options, register listeners, add methods,
  // etc.

  Browser.extend = function extend(extension) {
    this._extensions.push(extension);
  };

  // Call this to return a debug() instance with debugging enabled.

  Browser._enableDebugging = function _enableDebugging() {
    // With debugging enabled, every time we call debug('zombie') we get a new
    // instance which outputs with a different color.  This can be confusing, so
    // if debugging is already enabled (DEBUG=zombie) we want to use the current
    // instance.  Otherwise, we want to create a new instance (_debugEnabled)
    // and reuse it every time someone calls browser.debug().
    if (this._debug.enabled) {
      return this._debug.enabled;
    }if (!this._debugEnabled) {
      debug.enable("zombie");
      this._debugEnabled = debug("zombie");
    }
    return this._debugEnabled;
  };

  _createClass(Browser, {
    window: {

      // Windows
      // -------

      // Returns the currently open window

      get: function () {
        return this.tabs.current;
      }
    },
    error: {

      // browser.error => Error
      //
      // Returns the last error reported while loading this window.

      get: function () {
        return this.errors[this.errors.length - 1];
      }
    },
    document: {

      // browser.document => Document
      //
      // Returns the main window's document. Only valid after opening a document (see `browser.open`).

      get: function () {
        return this.window && this.window.document;
      }
    },
    body: {

      // browser.body => Element
      //
      // Returns the body Element of the current document.

      get: function () {
        return this.querySelector("body");
      }
    },
    activeElement: {

      // Element that has the current focus.

      get: function () {
        return this.document && this.document.activeElement;
      }
    },
    location: {

      // browser.location => Location
      //
      // Return the location of the current document (same as `window.location`).

      get: function () {
        return this.window && this.window.location;
      },

      // browser.location = url
      //
      // Changes document location, loads new document if necessary (same as setting `window.location`).
      set: function (url) {
        if (this.window) this.window.location = url;else this.open({ url: url });
      }
    },
    url: {

      // browser.url => String
      //
      // Return the URL of the current document (same as `document.URL`).

      get: function () {
        return this.window && this.window.location.href;
      }
    },
    history: {

      // Return the history object.

      get: function () {
        if (!this.window) this.open();
        return this.window.history;
      }
    },
    statusCode: {
      get: function () {
        return this.window && this.window._response ? this.window._response.statusCode : null;
      }
    },
    success: {
      get: function () {
        var statusCode = this.statusCode;
        return statusCode >= 200 && statusCode < 400;
      }
    },
    redirected: {
      get: function () {
        return this.window && this.window._response && this.window._response.redirects > 0;
      }
    },
    source: {
      get: function () {
        return this.window && this.window._response ? this.window._response.body : null;
      }
    }
  });

  return Browser;
})(EventEmitter);

_core.Object.assign(Browser, {

  Assert: Assert,
  Resources: Resources,
  VERSION: VERSION,

  // -- These defaults are used in any new browser instance --

  // Which features are enabled.
  features: DEFAULT_FEATURES,

  // Tells the browser how many redirects to follow before aborting a request. Defaults to 5
  maxRedirects: 5,

  // Proxy URL.
  //
  // Example
  //   Browser.proxy = 'http://myproxy:8080'
  proxy: null,

  // If true, supress `console.log` output from scripts (ignored when DEBUG=zombie)
  silent: false,

  // You can use visit with a path, and it will make a request relative to this host/URL.
  site: null,

  // Check SSL certificates against CA.  False by default since you're likely
  // testing with a self-signed certificate.
  strictSSL: false,

  // Sets the outgoing IP address in case there is more than on available.
  // Defaults to 0.0.0.0 which should select default interface
  localAddress: "0.0.0.0",

  // User agent string sent to server.
  userAgent: "Mozilla/5.0 Chrome/10.0.613.0 Safari/534.15 Zombie.js/" + VERSION,

  // Navigator language code
  language: "en-US",

  // Default time to wait (visit, wait, etc).
  waitDuration: "5s",

  // Indicates whether or not to validate and execute JavaScript, default true.
  runScripts: true,

  // -- Internal properties --

  // Debug instance.  Create new instance when enabling debugging with Zombie.debug
  _debug: debug("zombie"),

  // Set after calling _enableDebugging
  _debugEnabled: null,

  // Browser extensions;
  _extensions: [] });

module.exports = Browser;

// Invalid selector, but may be valid field name
//# sourceMappingURL=index.js.map